<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | kurobaraのブログ]]></title>
  <link href="http://moonstruckdrops.github.com/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://moonstruckdrops.github.com/"/>
  <updated>2015-02-18T01:30:08+09:00</updated>
  <id>http://moonstruckdrops.github.com/</id>
  <author>
    <name><![CDATA[kurobara]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linuxのログイン履歴確認]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2015/02/18/linux-login-check/"/>
    <updated>2015-02-18T01:20:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2015/02/18/linux-login-check</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<hr />

<p>毎度なんだっけ？ってなって思い出すのが面倒なので、備忘録的にログイン履歴確認方法を記録</p>

<h3>最近ログインしたアカウント一覧</h3>

<hr />

<p>以下のコマンドで確認できる</p>

<p><code>
$last
</code></p>

<p>実行結果(上に行くほど最新)</p>

<p><code>
root     tty1                          Tue May  6 18:59 - crash  (00:16)
root     tty1                          Tue May  6 18:58 - 18:59  (00:00)
reboot   system boot  2.6.32-431.11.2. Tue May  6 17:16 - 21:21  (04:04)
</code></p>

<h3>ログファイルから確認する</h3>

<hr />

<p>もう少し細かく見る場合はログファイルを確認する<br/>
バイナリなので中を見たいときはwhoコマンドを使用する</p>

<p><code>
$who /var/log/wtmp
</code></p>

<p>実行結果(ログファイルなので、ファイル末尾が新しい)</p>

<p><code>
root     tty1         2014-05-06 18:58
root     tty1         2014-05-06 18:59
root     tty1         2014-05-06 19:19
</code></p>

<h3>各アカウントの最終ログインの一覧</h3>

<hr />

<p>普段利用していないアカウントでログインされていないか確認できる<br/>
以下のコマンドで確認できる</p>

<p><code>
$lastlog
</code></p>

<p>実行結果(各アカウントの最終ログインが表示)</p>

<p><code>
ユーザ名         ポート   場所             最近のログイン
root             tty1                      **一度もログインしていません**
bin                                        **一度もログインしていません**
daemon                                     **一度もログインしていません**
adm                                        **一度もログインしていません**
lp                                         **一度もログインしていません**
sync                                       **一度もログインしていません**
shutdown                                   **一度もログインしていません**
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[findのexecオプションとxargsコマンドについて]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2014/01/01/find-delete/"/>
    <updated>2014-01-01T21:36:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2014/01/01/find-delete</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<hr />

<p>年が明けましたね。</p>

<p>せっかくの休みなので、今まで溜め込んだファイルの整理をすることにしました。</p>

<p>無駄なファイルが山ほどあって、検索からの削除を便利にしよう</p>

<p>そう思ったのが今回の発端です。</p>

<p>さて、やります。</p>

<h3>ファイル検索といえば</h3>

<hr />

<p>findコマンドを使いますね。</p>

<p>execオプションやパイプとともにxargsコマンドを駆使して検索したファイルに対して処理をします。</p>

<p>今回の要件ファイル削除系だとこんな感じですね。</p>

<p><code>
$find . -name "*.dummy" -exec rm {} \;
</code></p>

<p>xargsを使う場合だと、こっちですね。</p>

<p><code>
$find . -name "*.dummy" -print0 | xargs -0 -n1 rm
</code></p>

<p>因みに、print0オプションを有効にすると区切り文字がスペースから \0 に変更されます。<br/>
ファイル名にスペースがあるかもしれない場合とかはつけておくことがよいと思います。</p>

<p>他にxargsの-0オプションも上記同様のものです。-n&lt;数字>は1 コマンドラインにつき最大の数字分ずつ引数として使用するという意味になります。</p>

<h3>execオプションでxargsと同様の処理</h3>

<hr />

<p>これをする場合は、+を使えばよいようです。</p>

<p><code>
$find . -name "*.dummy" -exec rm {}+
</code></p>

<p>これだけだと意味があるような、ないような<sup>^;;</sup></p>

<h3>findのdeleteオプション</h3>

<hr />

<p>OS依存になるようですが、findコマンドにはdeleteオプションがあるようです。<br/>
これを使えば、上記のようにコマンドの組み合わせをせずともファイル検索→ファイル削除も同時にできるようです。</p>

<p><code>
$find . -name "*.dummy" -print0 -delete
</code></p>

<p>検索と同時に削除なので、危険な感じがしますが、便利に使えると思います。</p>

<h3>まとめ</h3>

<hr />

<p>大したことでもないですが、こんな感じですね</p>

<ul>
<li>findとxargsを組み合わせる場合、find側はprint0オプション、xargs側は-0オプションを付けたほうが安全</li>
<li>findコマンドでxargsと同様のことがしたい場合、execオプションの末尾を;から+に変更する</li>
<li>検索+削除の場合、findコマンドのdeleteオプションを使うと便利</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSHで複数の鍵を管理する]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/08/22/ssh-config-setting/"/>
    <updated>2013-08-22T21:29:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/08/22/ssh-config-setting</id>
    <content type="html"><![CDATA[<p>SSHで鍵やユーザ名を複数のホストで使い分けないといけないときは結構面倒です。
ホスト毎の設定は「~/.ssh/config」で設定できます。</p>

<h3>管理方法</h3>

<hr />

<p>以下の方法で管理します。</p>

<ul>
<li>鍵毎にprefixやsuffixをつける</li>
<li>sshのconfigにホスト毎に設定をつける</li>
</ul>


<p>因みに、鍵がわかれば鍵ファイル名はなんでもいいです。</p>

<h3>configの記載</h3>

<hr />

<p>以下のような形で記載します。</p>

<p>```
Host github.com</p>

<pre><code>HostName        github.com
IdentityFile    ~/.ssh/github_id_rsa
User            git
TCPKeepAlive    yes
IdentitiesOnly  yes
</code></pre>

<p>Host hogehoge</p>

<pre><code>HostName        hogehoge
Port            12345
IdentityFile    ~/.ssh/hogehoge_id_rsa
User            hogehoge
Protocol        2
</code></pre>

<p>```</p>

<p>各項目は以下の内容を設定しています。</p>

<table>
<thead>
<tr>
<th align="left">設定項目</th>
<th align="left">設定値</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Host</td>
<td align="left">次のHostキーワードが現れるまでの項目が１つの設定項目にする</td>
</tr>
<tr>
<td align="left">HostName</td>
<td align="left">ログイン先のホスト名</td>
</tr>
<tr>
<td align="left">IdentityFile</td>
<td align="left">SSHの鍵ファイル</td>
</tr>
<tr>
<td align="left">User</td>
<td align="left">ログインするユーザー名</td>
</tr>
<tr>
<td align="left">TCPKeepAlive</td>
<td align="left">持続的接続</td>
</tr>
<tr>
<td align="left">IdentitiesOnly</td>
<td align="left">IdentityFileを利用する場合に設定する</td>
</tr>
<tr>
<td align="left">Port</td>
<td align="left">ポート番号</td>
</tr>
<tr>
<td align="left">Protocol</td>
<td align="left">SSHのプロトコル指定</td>
</tr>
</tbody>
</table>


<p>githubへのログインの場合は、上記の内容を記載します。</p>

<h3>接続確認</h3>

<hr />

<p>以下のコマンドで確認します</p>

<p><code>
$ssh -T &lt;Host&gt;
</code></p>

<p>例えば、上記のconfigに設定したgithubへのアクセスは以下で確認します。</p>

<p><code>
$ssh -T github.com
</code></p>

<p>これで、「You've successfully authenticated」が出れば成功です。</p>

<p>以上で複数の鍵を管理できますね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linuxに接続したHDDを知る方法]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/08/12/find-hdd/"/>
    <updated>2013-08-12T00:09:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/08/12/find-hdd</id>
    <content type="html"><![CDATA[<p>バックアップ作業とかマウントとかで指定するんだけど・・・<br/>
どこだっけって探しまわるのも面倒なので、やり方をメモしておきます。</p>

<h3>方法1:dmesgコマンドを使用</h3>

<hr />

<p>出力された結果をgrepします。</p>

<h5>SATAの場合</h5>

<p><code>
$dmesg | grep sd
</code></p>

<h5>USB,PATAの場合</h5>

<p><code>
$dmesg |grep hd
</code></p>

<h3>方法2:dfコマンドを使用</h3>

<hr />

<p>自動マウントとかされている場合なんかだとこっちを使う</p>

<p><code>
$df
</code></p>

<p>結果を見れば、どのディスクがありどんなパーティションがあるか一目瞭然です。</p>

<h3>方法3:/dev配下の内容+fdiskコマンドを使用</h3>

<hr />

<p>接続中のデバイスを知るには、lsコマンドで/dev配下を知ります。<br/>
以下の表のような感じになります。実際の割り当ては、OSやディストリに依存</p>

<table>
<thead>
<tr>
<th align="left">パス</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">/dev/hda</td>
<td align="left">IDEプライマリー(USB)のマスターディスク(hd以降は何が割り当てられるかはOS依存)</td>
</tr>
<tr>
<td align="left">/dev/hda1</td>
<td align="left">数字が付けば、パーティション</td>
</tr>
<tr>
<td align="left">/dev/sda</td>
<td align="left">SATAもしくはSCSI</td>
</tr>
<tr>
<td align="left">/dev/sda1</td>
<td align="left">SATAもしくはSCSIのパーティション</td>
</tr>
<tr>
<td align="left">/dev/md0</td>
<td align="left">ソフトウェアRAID</td>
</tr>
</tbody>
</table>


<p>接続中のデバイスがわかれば、以下のコマンドで詳細情報を得ます</p>

<p><code>
$fdisk -l /dev/sda
</code></p>

<h3>方法4:/dev配下の内容+hdparmコマンドを使用</h3>

<hr />

<p>方法3と同じようにします。</p>

<p><code>
$hdparm -i /dev/sda
</code></p>

<p>fdiskがデバイスの情報に特化したものに対して、こっちは制御情報だったりステータスまで出てきます。</p>

<h3>余談</h3>

<hr />

<p>単純にUSBで接続したディスクであれば、lsusbコマンドを使えばよかったりします。<br/>
ターゲットのディスクがわかれば、マウントも簡単になります。<br/>
マウントポイント(自分で決めて、作成する)を「/mnt/hdd」とした場合、以下のコマンドでマウント可能</p>

<p><code>
$mount /dev/sda1 /mnt/hdd
</code></p>

<p>自分は、方法1と方法3をよく使います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DDコマンドで物理ディスクをバックアップする]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/08/11/make-disk-backup/"/>
    <updated>2013-08-11T21:22:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/08/11/make-disk-backup</id>
    <content type="html"><![CDATA[<p>どうも、どうも。久しぶりの更新です。<br/>
ゴタゴタが続いてたり、続いていなかったりでして。<br/>
更新するような感じのことができていません(勉強しろ)<br/>
まぁそんなどうでもいいことは置いておきまして、本題に入ります。</p>

<h3>発端</h3>

<hr />

<p>最近、とある目的のためにWindowsPCを買いました。<br/>
中古で安く買ったのはいいのですが、ライセンス的なもので復旧用のディスクを頂けませんでした。<br/>
頂けない上にちょっとアレな感じなところもありまして・・・</p>

<p>とりあえず、以下でゴニョゴニョやってみました。</p>

<ol>
<li>Windows7に標準で搭載されているバックアップツール</li>
<li>出処不明のリカバリーディスク</li>
</ol>


<p>結果として、どちらも失敗でした。<br/>
1はリカバーしたら古い情報も残ります。<br/>
残るだけならまだしも、色々ファイルも消えます。<br/>
2なんかは、インストールでドライバー用意しろと言われました。<br/>
なんか、ディスク起動もやたら遅いので怪しい感じ。。。</p>

<p>仕方ないので、ディスク換装した上に<br/>
元のドライブのデータを全て換装後のディスクにコピーして保存するようにしました。</p>

<h3>バックアップ方法</h3>

<hr />

<p>ディスクのバックアップ方法ですが、「dd」コマンドを使用します。<br/>
このコマンドですが、「ハードディスク・パーティションを0/1の信号のママ丸ごとコピー」するものです。<br/>
注意点とすれば、以下のことでしょうか。</p>

<ul>
<li>ハードディスクの容量がコピー元以上であること</li>
<li>コマンドで指定するディスクを間違えて指定した場合、データが消滅すること</li>
</ul>


<h3>バックアップ例</h3>

<hr />

<p>以下のような条件とします。</p>

<ul>
<li>ディスクサイズは、「コピー先HDD ≧コピー元HDD」の大きさとすること</li>
<li>パーティションは、mountしないこと</li>
<li>コピー元HDDのパス、「/dev/sdb」</li>
<li>コピー先HDDのパス、/dev/sdc」</li>
</ul>


<p>以下のコマンドで、上記のデータをコピーすることができます。</p>

<p><code>
$dd if=/dev/sdb of=/dev/sdc bs=512 conv=noerror,sync
</code></p>

<p>これで、コピーができます。
但し、完了までに数時間かかります。</p>

<p>さて、これでディスクからディスクにコピーすることができました。
それだけでなくバックアップ用のディスクイメージをつくることが出来ます</p>

<p><code>
$dd if=/dev/sdb of=./backup-disk-image.img bs=512 conv=noerror,sync
</code></p>

<h3>故障ディスクのコピー</h3>

<hr />

<p>上記のコマンドを使えば、故障している(ある程度読める必要がありますが)ものまでコピーできます。<br/>
まぁ強引に読んでる(読めないところは、スキップしています)だけです。</p>

<p>上記のコマンドに設定しているオプションは、以下の表の意味です。</p>

<table>
<thead>
<tr>
<th align="left">オプション </th>
<th align="left"> 内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">noerror</td>
<td align="left">エラー読み飛ばし</td>
</tr>
<tr>
<td align="left">sync</td>
<td align="left">エラー箇所をNUL(ゼロ）で埋める</td>
</tr>
<tr>
<td align="left">bs</td>
<td align="left">byte size 読込書き出すバイトサイズ</td>
</tr>
</tbody>
</table>


<p>因みに、byte size値が大きいとコピー速度が速くなります。<br/>
但し、壊れている部分があると道連れになる部分が大きくなります。<br/>
なので、byte size値を小さくするとエラー範囲は最小になります(コピー速度が遅くなります)</p>

<h3>転送状況の表示</h3>

<hr />

<p>ddコマンドには、転送状況を表示してくれるようなオプションはありません。<br/>
以下のように、killallコマンドのUSRオプションで途中経過を表示できます。</p>

<p><code>
$killall -USR1 dd
</code></p>

<p>これで、どれくらいかかるか時間計算ができますね。</p>

<h3>ディスクイメージからの復元方法</h3>

<hr />

<p>ディスクイメージのバックアップは取れましたが、ディスクイメージからの復元が必要ですね。<br/>
といっても、ここまでで大まかに理解できそうな感じがしますが・・・</p>

<p><code>
$dd if=./backup-disk-image.img of=/dev/sdb bs=512 conv=noerror,sync
</code></p>

<p>コピー元とコピー先を入れ替えるだけですね。</p>

<h3>ディスクの消去</h3>

<hr />

<p>復元と同じ要領で、zero埋めすれば完全フォーマットができます。</p>

<p><code>
$dd if=/dev/zero of=/dev/sdc
</code></p>

<p>このコマンド本当に便利。<br/>
LinuxとかMacのディスクだけでなくって、Windowsなディスクまで丸ごとコピーできるところが素敵。<br/>
ファイル指定はできないけどw</p>
]]></content>
  </entry>
  
</feed>
