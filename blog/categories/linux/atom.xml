<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | kurobaraのブログ]]></title>
  <link href="http://moonstruckdrops.github.com/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://moonstruckdrops.github.com/"/>
  <updated>2013-08-22T00:16:38+09:00</updated>
  <id>http://moonstruckdrops.github.com/</id>
  <author>
    <name><![CDATA[kurobara]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linuxに接続したHDDを知る方法]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/08/12/find-hdd/"/>
    <updated>2013-08-12T00:09:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/08/12/find-hdd</id>
    <content type="html"><![CDATA[<p>バックアップ作業とかマウントとかで指定するんだけど・・・<br/>
どこだっけって探しまわるのも面倒なので、やり方をメモしておきます。</p>

<h3>方法1:dmesgコマンドを使用</h3>

<hr />

<p>出力された結果をgrepします。</p>

<h5>SATAの場合</h5>

<p><code>
$dmesg | grep sd
</code></p>

<h5>USB,PATAの場合</h5>

<p><code>
$dmesg |grep hd
</code></p>

<h3>方法2:dfコマンドを使用</h3>

<hr />

<p>自動マウントとかされている場合なんかだとこっちを使う</p>

<p><code>
$df
</code></p>

<p>結果を見れば、どのディスクがありどんなパーティションがあるか一目瞭然です。</p>

<h3>方法3:/dev配下の内容+fdiskコマンドを使用</h3>

<hr />

<p>接続中のデバイスを知るには、lsコマンドで/dev配下を知ります。<br/>
以下の表のような感じになります。実際の割り当ては、OSやディストリに依存</p>

<table>
<thead>
<tr>
<th align="left">パス</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">/dev/hda</td>
<td align="left">IDEプライマリー(USB)のマスターディスク(hd以降は何が割り当てられるかはOS依存)</td>
</tr>
<tr>
<td align="left">/dev/hda1</td>
<td align="left">数字が付けば、パーティション</td>
</tr>
<tr>
<td align="left">/dev/sda</td>
<td align="left">SATAもしくはSCSI</td>
</tr>
<tr>
<td align="left">/dev/sda1</td>
<td align="left">SATAもしくはSCSIのパーティション</td>
</tr>
<tr>
<td align="left">/dev/md0</td>
<td align="left">ソフトウェアRAID</td>
</tr>
</tbody>
</table>


<p>接続中のデバイスがわかれば、以下のコマンドで詳細情報を得ます</p>

<p><code>
$fdisk -l /dev/sda
</code></p>

<h3>方法4:/dev配下の内容+hdparmコマンドを使用</h3>

<hr />

<p>方法3と同じようにします。</p>

<p><code>
$hdparm -i /dev/sda
</code></p>

<p>fdiskがデバイスの情報に特化したものに対して、こっちは制御情報だったりステータスまで出てきます。</p>

<h3>余談</h3>

<hr />

<p>単純にUSBで接続したディスクであれば、lsusbコマンドを使えばよかったりします。<br/>
ターゲットのディスクがわかれば、マウントも簡単になります。<br/>
マウントポイント(自分で決めて、作成する)を「/mnt/hdd」とした場合、以下のコマンドでマウント可能</p>

<p><code>
$mount /dev/sda1 /mnt/hdd
</code></p>

<p>自分は、方法1と方法3をよく使います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DDコマンドで物理ディスクをバックアップする]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/08/11/make-disk-backup/"/>
    <updated>2013-08-11T21:22:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/08/11/make-disk-backup</id>
    <content type="html"><![CDATA[<p>どうも、どうも。久しぶりの更新です。<br/>
ゴタゴタが続いてたり、続いていなかったりでして。<br/>
更新するような感じのことができていません(勉強しろ)<br/>
まぁそんなどうでもいいことは置いておきまして、本題に入ります。</p>

<h3>発端</h3>

<hr />

<p>最近、とある目的のためにWindowsPCを買いました。<br/>
中古で安く買ったのはいいのですが、ライセンス的なもので復旧用のディスクを頂けませんでした。<br/>
頂けない上にちょっとアレな感じなところもありまして・・・</p>

<p>とりあえず、以下でゴニョゴニョやってみました。</p>

<ol>
<li>Windows7に標準で搭載されているバックアップツール</li>
<li>出処不明のリカバリーディスク</li>
</ol>


<p>結果として、どちらも失敗でした。<br/>
1はリカバーしたら古い情報も残ります。<br/>
残るだけならまだしも、色々ファイルも消えます。<br/>
2なんかは、インストールでドライバー用意しろと言われました。<br/>
なんか、ディスク起動もやたら遅いので怪しい感じ。。。</p>

<p>仕方ないので、ディスク換装した上に<br/>
元のドライブのデータを全て換装後のディスクにコピーして保存するようにしました。</p>

<h3>バックアップ方法</h3>

<hr />

<p>ディスクのバックアップ方法ですが、「dd」コマンドを使用します。<br/>
このコマンドですが、「ハードディスク・パーティションを0/1の信号のママ丸ごとコピー」するものです。<br/>
注意点とすれば、以下のことでしょうか。</p>

<ul>
<li>ハードディスクの容量がコピー元以上であること</li>
<li>コマンドで指定するディスクを間違えて指定した場合、データが消滅すること</li>
</ul>


<h3>バックアップ例</h3>

<hr />

<p>以下のような条件とします。</p>

<ul>
<li>ディスクサイズは、「コピー先HDD ≧コピー元HDD」の大きさとすること</li>
<li>パーティションは、mountしないこと</li>
<li>コピー元HDDのパス、「/dev/sdb」</li>
<li>コピー先HDDのパス、/dev/sdc」</li>
</ul>


<p>以下のコマンドで、上記のデータをコピーすることができます。</p>

<p><code>
$dd if=/dev/sdb of=/dev/sdc bs=512 conv=noerror,sync
</code></p>

<p>これで、コピーができます。
但し、完了までに数時間かかります。</p>

<p>さて、これでディスクからディスクにコピーすることができました。
それだけでなくバックアップ用のディスクイメージをつくることが出来ます</p>

<p><code>
$dd if=/dev/sdb of=./backup-disk-image.img bs=512 conv=noerror,sync
</code></p>

<h3>故障ディスクのコピー</h3>

<hr />

<p>上記のコマンドを使えば、故障している(ある程度読める必要がありますが)ものまでコピーできます。<br/>
まぁ強引に読んでる(読めないところは、スキップしています)だけです。</p>

<p>上記のコマンドに設定しているオプションは、以下の表の意味です。</p>

<table>
<thead>
<tr>
<th align="left">オプション </th>
<th align="left"> 内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">noerror</td>
<td align="left">エラー読み飛ばし</td>
</tr>
<tr>
<td align="left">sync</td>
<td align="left">エラー箇所をNUL(ゼロ）で埋める</td>
</tr>
<tr>
<td align="left">bs</td>
<td align="left">byte size 読込書き出すバイトサイズ</td>
</tr>
</tbody>
</table>


<p>因みに、byte size値が大きいとコピー速度が速くなります。<br/>
但し、壊れている部分があると道連れになる部分が大きくなります。<br/>
なので、byte size値を小さくするとエラー範囲は最小になります(コピー速度が遅くなります)</p>

<h3>転送状況の表示</h3>

<hr />

<p>ddコマンドには、転送状況を表示してくれるようなオプションはありません。<br/>
以下のように、killallコマンドのUSRオプションで途中経過を表示できます。</p>

<p><code>
$killall -USR1 dd
</code></p>

<p>これで、どれくらいかかるか時間計算ができますね。</p>

<h3>ディスクイメージからの復元方法</h3>

<hr />

<p>ディスクイメージのバックアップは取れましたが、ディスクイメージからの復元が必要ですね。<br/>
といっても、ここまでで大まかに理解できそうな感じがしますが・・・</p>

<p><code>
$dd if=./backup-disk-image.img of=/dev/sdb bs=512 conv=noerror,sync
</code></p>

<p>コピー元とコピー先を入れ替えるだけですね。</p>

<h3>ディスクの消去</h3>

<hr />

<p>復元と同じ要領で、zero埋めすれば完全フォーマットができます。</p>

<p><code>
$dd if=/dev/zero of=/dev/sdc
</code></p>

<p>このコマンド本当に便利。<br/>
LinuxとかMacのディスクだけでなくって、Windowsなディスクまで丸ごとコピーできるところが素敵。<br/>
ファイル指定はできないけどw</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux上にあるユーザーアカウントの追加と削除をする]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/04/24/linux-user-add/"/>
    <updated>2013-04-24T23:40:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/04/24/linux-user-add</id>
    <content type="html"><![CDATA[<p>すごくド基礎なのですが・・・。<br/>
ユーザーアカウント削除ってどうやるんだっけな？ってなったのでついでにメモしておく。</p>

<h3>ユーザーアカウントの追加</h3>

<hr />

<p>基本中の基本ですね。<br/>
以下のコマンドのような感じで追加します。</p>

<p><code>
$useradd -u 500 -g wheel -m kurobara
</code></p>

<p>以下の表によく使用するオプションを記載します。</p>

<table>
<thead>
<tr>
<th align="left">オプション</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">c コメント      </td>
<td align="left">ユーザーのコメントを設定</td>
</tr>
<tr>
<td align="left">d ディレクトリ  </td>
<td align="left">ユーザーのログインディレクトリを指定</td>
</tr>
<tr>
<td align="left">e mm/dd/yy </td>
<td align="left">ユーザーの有効期限をmm/dd/yy形式で指定</td>
</tr>
<tr>
<td align="left">g グループ   </td>
<td align="left">ユーザーの所属するイニシャル・グループを指定</td>
</tr>
<tr>
<td align="left">G グループ    </td>
<td align="left">ユーザーの所属するグループを指定します(「,」で複数指定可能)</td>
</tr>
<tr>
<td align="left">u ユーザーID </td>
<td align="left">ユーザーのユーザーIDを指定</td>
</tr>
<tr>
<td align="left">s シェル </td>
<td align="left">ユーザーのログインシェルを指定</td>
</tr>
<tr>
<td align="left">m        </td>
<td align="left">ホームディレクトリの作成を自動で行う</td>
</tr>
</tbody>
</table>


<h3>ユーザーアカウントの削除</h3>

<hr />

<p>以下のコマンドでユーザーアカウントの削除ができます。<br/>
なお、オプションにrを付与すると、ホームディレクトリまで削除してくれます。<br/>
但し、他のファイルシステムにあるファイル等は探しだして手動で削除する必要があります。</p>

<p><code>
$userdel &lt;ユーザーアカウント名&gt;
</code></p>

<p>常識ですね(ぉぃ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[コマンドで暗号化Zipファイルを作成する]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/04/22/zip-pass/"/>
    <updated>2013-04-22T23:48:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/04/22/zip-pass</id>
    <content type="html"><![CDATA[<h3>暗号化Zipファイル作成</h3>

<hr />

<p>大概GUIありのツールでやってしまうのですが、必要に駆られたのでコマンドでやることになりました。<br/>
以下のようにzipコマンドのeオプションを使うだけで簡単にできます。</p>

<p><code>
$zip -e &lt;zipファイル名&gt; &lt;圧縮対象のファイル&gt;
</code></p>

<p>恥ずかしながらあんまりやらないので、いざというときには忘れてしまいます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3分で認証とか考慮しないWebDavを構築してみる]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/04/02/httpd-webdav/"/>
    <updated>2013-04-02T00:30:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/04/02/httpd-webdav</id>
    <content type="html"><![CDATA[<p>大したことはないし、そこらへんに構築メモは転がってるので要らないと思うけど・・・</p>

<p>という訳で、一から最低限の機能のみを構築しますという体で進めます。<br/>
日本語の文字化け対策にエンコーディングを入れてーみたいなことはしません。</p>

<p>動かすことのみに注力します。</p>

<h3>環境</h3>

<hr />

<p>・CentOS6.3 x86_64</p>

<h3>Apacheのインストール</h3>

<hr />

<p>以下のコマンドでApacheをインストールします。<br/>
このとき、インストールするパッケージはdevelにします。(色々必要なものが一緒に入るので)</p>

<p><code>
$sudo yum install httpd-devel
</code></p>

<h3>モジュールの確認</h3>

<hr />

<p>WebDavは、Apacheの追加モジュールです。<br/>
develパッケージでインストールした場合、自動でインストールされますが念の為に確認します。<br/>
以下の２つが、「/etc/httpd/conf/httpd.conf」に記載されているか確認します。</p>

<ul>
<li>LoadModule dav_module modules/mod_dav.so</li>
<li>LoadModule dav_fs_module modules/mod_dav_fs.so</li>
</ul>


<p>記載が無ければ、「/usr/lib/httpd/modules/」に上記モジュールがあるか確認します。<br/>
モジュールが存在していれば、追加しましょう。</p>

<h3>WebDavの設定</h3>

<hr />

<p>以下の内容で、「/etc/httpd/conf.d/webdav.conf」を作成します。<br/>
ACLやBasic認証とかもここで設定できますが、最低限動作なので実施しません。<br/>
因みに、ディレクトリに対して細かい設定ができます。</p>

<p>```
#</p>

<h1>This is to permit URL access to WebDav.</h1>

<p>#
Alias /webdav/ "/var/www/html/webdav/"
<IfModule mod_dav.c></p>

<pre><code>DAVMinTimeout 600
&lt;Location /webdav&gt;
    DAV On
&lt;/Location&gt;
</code></pre>

<p></IfModule>
```</p>

<h3>WebDav用のディレクトリ作成</h3>

<hr />

<p>WebDavとして共有するためのディレクトリを作成します。
<code>
$sudo mkdir -p /var/www/html/webdav
</code>
ディレクトリをApacheから制御できるように所有者・所有グループを「apache」に変更します。
<code>
$sudo chown apache:apache /var/www/html/webdav
</code></p>

<h3>iptablesの設定</h3>

<hr />

<p>iptablesを未設定のままにすると、iptablesによってアクセスできないので、80番ポートのアクセスを許可するように設定変更します。<br/>
<code>
$sudo emacs /etc/sysconfig/iptables
</code></p>

<p>80番での通信を許可するよう、以下の内容をREJECTの前に追加します。
<code>
-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT
</code></p>

<p>iptablesを再起動します。
<code>
$sudo /etc/init.d/iptables restart
</code></p>

<h3>Apacheの起動</h3>

<hr />

<p>以下のコマンドで起動します。</p>

<p><code>
$sudo /etc/init.d/httpd start
</code></p>

<p><a href="http://localhost/webdav">http://localhost/webdav</a>にアクセス出来れば完了です。</p>

<p>この程度だと、大したことないし知ってれば３分要らないかもw</p>
]]></content>
  </entry>
  
</feed>
