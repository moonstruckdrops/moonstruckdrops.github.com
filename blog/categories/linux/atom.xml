<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | kurobaraのブログ]]></title>
  <link href="http://moonstruckdrops.github.com/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://moonstruckdrops.github.com/"/>
  <updated>2013-12-21T13:16:52+09:00</updated>
  <id>http://moonstruckdrops.github.com/</id>
  <author>
    <name><![CDATA[kurobara]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SSHで複数の鍵を管理する]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/08/22/ssh-config-setting/"/>
    <updated>2013-08-22T21:29:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/08/22/ssh-config-setting</id>
    <content type="html"><![CDATA[<p>SSHで鍵やユーザ名を複数のホストで使い分けないといけないときは結構面倒です。
ホスト毎の設定は「~/.ssh/config」で設定できます。</p>

<h3>管理方法</h3>

<hr />

<p>以下の方法で管理します。</p>

<ul>
<li>鍵毎にprefixやsuffixをつける</li>
<li>sshのconfigにホスト毎に設定をつける</li>
</ul>


<p>因みに、鍵がわかれば鍵ファイル名はなんでもいいです。</p>

<h3>configの記載</h3>

<hr />

<p>以下のような形で記載します。</p>

<p>```
Host github.com</p>

<pre><code>HostName        github.com
IdentityFile    ~/.ssh/github_id_rsa
User            git
TCPKeepAlive    yes
IdentitiesOnly  yes
</code></pre>

<p>Host hogehoge</p>

<pre><code>HostName        hogehoge
Port            12345
IdentityFile    ~/.ssh/hogehoge_id_rsa
User            hogehoge
Protocol        2
</code></pre>

<p>```</p>

<p>各項目は以下の内容を設定しています。</p>

<table>
<thead>
<tr>
<th align="left">設定項目</th>
<th align="left">設定値</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Host</td>
<td align="left">次のHostキーワードが現れるまでの項目が１つの設定項目にする</td>
</tr>
<tr>
<td align="left">HostName</td>
<td align="left">ログイン先のホスト名</td>
</tr>
<tr>
<td align="left">IdentityFile</td>
<td align="left">SSHの鍵ファイル</td>
</tr>
<tr>
<td align="left">User</td>
<td align="left">ログインするユーザー名</td>
</tr>
<tr>
<td align="left">TCPKeepAlive</td>
<td align="left">持続的接続</td>
</tr>
<tr>
<td align="left">IdentitiesOnly</td>
<td align="left">IdentityFileを利用する場合に設定する</td>
</tr>
<tr>
<td align="left">Port</td>
<td align="left">ポート番号</td>
</tr>
<tr>
<td align="left">Protocol</td>
<td align="left">SSHのプロトコル指定</td>
</tr>
</tbody>
</table>


<p>githubへのログインの場合は、上記の内容を記載します。</p>

<h3>接続確認</h3>

<hr />

<p>以下のコマンドで確認します</p>

<p><code>
$ssh -T &lt;Host&gt;
</code></p>

<p>例えば、上記のconfigに設定したgithubへのアクセスは以下で確認します。</p>

<p><code>
$ssh -T github.com
</code></p>

<p>これで、「You've successfully authenticated」が出れば成功です。</p>

<p>以上で複数の鍵を管理できますね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linuxに接続したHDDを知る方法]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/08/12/find-hdd/"/>
    <updated>2013-08-12T00:09:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/08/12/find-hdd</id>
    <content type="html"><![CDATA[<p>バックアップ作業とかマウントとかで指定するんだけど・・・<br/>
どこだっけって探しまわるのも面倒なので、やり方をメモしておきます。</p>

<h3>方法1:dmesgコマンドを使用</h3>

<hr />

<p>出力された結果をgrepします。</p>

<h5>SATAの場合</h5>

<p><code>
$dmesg | grep sd
</code></p>

<h5>USB,PATAの場合</h5>

<p><code>
$dmesg |grep hd
</code></p>

<h3>方法2:dfコマンドを使用</h3>

<hr />

<p>自動マウントとかされている場合なんかだとこっちを使う</p>

<p><code>
$df
</code></p>

<p>結果を見れば、どのディスクがありどんなパーティションがあるか一目瞭然です。</p>

<h3>方法3:/dev配下の内容+fdiskコマンドを使用</h3>

<hr />

<p>接続中のデバイスを知るには、lsコマンドで/dev配下を知ります。<br/>
以下の表のような感じになります。実際の割り当ては、OSやディストリに依存</p>

<table>
<thead>
<tr>
<th align="left">パス</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">/dev/hda</td>
<td align="left">IDEプライマリー(USB)のマスターディスク(hd以降は何が割り当てられるかはOS依存)</td>
</tr>
<tr>
<td align="left">/dev/hda1</td>
<td align="left">数字が付けば、パーティション</td>
</tr>
<tr>
<td align="left">/dev/sda</td>
<td align="left">SATAもしくはSCSI</td>
</tr>
<tr>
<td align="left">/dev/sda1</td>
<td align="left">SATAもしくはSCSIのパーティション</td>
</tr>
<tr>
<td align="left">/dev/md0</td>
<td align="left">ソフトウェアRAID</td>
</tr>
</tbody>
</table>


<p>接続中のデバイスがわかれば、以下のコマンドで詳細情報を得ます</p>

<p><code>
$fdisk -l /dev/sda
</code></p>

<h3>方法4:/dev配下の内容+hdparmコマンドを使用</h3>

<hr />

<p>方法3と同じようにします。</p>

<p><code>
$hdparm -i /dev/sda
</code></p>

<p>fdiskがデバイスの情報に特化したものに対して、こっちは制御情報だったりステータスまで出てきます。</p>

<h3>余談</h3>

<hr />

<p>単純にUSBで接続したディスクであれば、lsusbコマンドを使えばよかったりします。<br/>
ターゲットのディスクがわかれば、マウントも簡単になります。<br/>
マウントポイント(自分で決めて、作成する)を「/mnt/hdd」とした場合、以下のコマンドでマウント可能</p>

<p><code>
$mount /dev/sda1 /mnt/hdd
</code></p>

<p>自分は、方法1と方法3をよく使います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DDコマンドで物理ディスクをバックアップする]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/08/11/make-disk-backup/"/>
    <updated>2013-08-11T21:22:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/08/11/make-disk-backup</id>
    <content type="html"><![CDATA[<p>どうも、どうも。久しぶりの更新です。<br/>
ゴタゴタが続いてたり、続いていなかったりでして。<br/>
更新するような感じのことができていません(勉強しろ)<br/>
まぁそんなどうでもいいことは置いておきまして、本題に入ります。</p>

<h3>発端</h3>

<hr />

<p>最近、とある目的のためにWindowsPCを買いました。<br/>
中古で安く買ったのはいいのですが、ライセンス的なもので復旧用のディスクを頂けませんでした。<br/>
頂けない上にちょっとアレな感じなところもありまして・・・</p>

<p>とりあえず、以下でゴニョゴニョやってみました。</p>

<ol>
<li>Windows7に標準で搭載されているバックアップツール</li>
<li>出処不明のリカバリーディスク</li>
</ol>


<p>結果として、どちらも失敗でした。<br/>
1はリカバーしたら古い情報も残ります。<br/>
残るだけならまだしも、色々ファイルも消えます。<br/>
2なんかは、インストールでドライバー用意しろと言われました。<br/>
なんか、ディスク起動もやたら遅いので怪しい感じ。。。</p>

<p>仕方ないので、ディスク換装した上に<br/>
元のドライブのデータを全て換装後のディスクにコピーして保存するようにしました。</p>

<h3>バックアップ方法</h3>

<hr />

<p>ディスクのバックアップ方法ですが、「dd」コマンドを使用します。<br/>
このコマンドですが、「ハードディスク・パーティションを0/1の信号のママ丸ごとコピー」するものです。<br/>
注意点とすれば、以下のことでしょうか。</p>

<ul>
<li>ハードディスクの容量がコピー元以上であること</li>
<li>コマンドで指定するディスクを間違えて指定した場合、データが消滅すること</li>
</ul>


<h3>バックアップ例</h3>

<hr />

<p>以下のような条件とします。</p>

<ul>
<li>ディスクサイズは、「コピー先HDD ≧コピー元HDD」の大きさとすること</li>
<li>パーティションは、mountしないこと</li>
<li>コピー元HDDのパス、「/dev/sdb」</li>
<li>コピー先HDDのパス、/dev/sdc」</li>
</ul>


<p>以下のコマンドで、上記のデータをコピーすることができます。</p>

<p><code>
$dd if=/dev/sdb of=/dev/sdc bs=512 conv=noerror,sync
</code></p>

<p>これで、コピーができます。
但し、完了までに数時間かかります。</p>

<p>さて、これでディスクからディスクにコピーすることができました。
それだけでなくバックアップ用のディスクイメージをつくることが出来ます</p>

<p><code>
$dd if=/dev/sdb of=./backup-disk-image.img bs=512 conv=noerror,sync
</code></p>

<h3>故障ディスクのコピー</h3>

<hr />

<p>上記のコマンドを使えば、故障している(ある程度読める必要がありますが)ものまでコピーできます。<br/>
まぁ強引に読んでる(読めないところは、スキップしています)だけです。</p>

<p>上記のコマンドに設定しているオプションは、以下の表の意味です。</p>

<table>
<thead>
<tr>
<th align="left">オプション </th>
<th align="left"> 内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">noerror</td>
<td align="left">エラー読み飛ばし</td>
</tr>
<tr>
<td align="left">sync</td>
<td align="left">エラー箇所をNUL(ゼロ）で埋める</td>
</tr>
<tr>
<td align="left">bs</td>
<td align="left">byte size 読込書き出すバイトサイズ</td>
</tr>
</tbody>
</table>


<p>因みに、byte size値が大きいとコピー速度が速くなります。<br/>
但し、壊れている部分があると道連れになる部分が大きくなります。<br/>
なので、byte size値を小さくするとエラー範囲は最小になります(コピー速度が遅くなります)</p>

<h3>転送状況の表示</h3>

<hr />

<p>ddコマンドには、転送状況を表示してくれるようなオプションはありません。<br/>
以下のように、killallコマンドのUSRオプションで途中経過を表示できます。</p>

<p><code>
$killall -USR1 dd
</code></p>

<p>これで、どれくらいかかるか時間計算ができますね。</p>

<h3>ディスクイメージからの復元方法</h3>

<hr />

<p>ディスクイメージのバックアップは取れましたが、ディスクイメージからの復元が必要ですね。<br/>
といっても、ここまでで大まかに理解できそうな感じがしますが・・・</p>

<p><code>
$dd if=./backup-disk-image.img of=/dev/sdb bs=512 conv=noerror,sync
</code></p>

<p>コピー元とコピー先を入れ替えるだけですね。</p>

<h3>ディスクの消去</h3>

<hr />

<p>復元と同じ要領で、zero埋めすれば完全フォーマットができます。</p>

<p><code>
$dd if=/dev/zero of=/dev/sdc
</code></p>

<p>このコマンド本当に便利。<br/>
LinuxとかMacのディスクだけでなくって、Windowsなディスクまで丸ごとコピーできるところが素敵。<br/>
ファイル指定はできないけどw</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux上にあるユーザーアカウントの追加と削除をする]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/04/24/linux-user-add/"/>
    <updated>2013-04-24T23:40:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/04/24/linux-user-add</id>
    <content type="html"><![CDATA[<p>すごくド基礎なのですが・・・。<br/>
ユーザーアカウント削除ってどうやるんだっけな？ってなったのでついでにメモしておく。</p>

<h3>ユーザーアカウントの追加</h3>

<hr />

<p>基本中の基本ですね。<br/>
以下のコマンドのような感じで追加します。</p>

<p><code>
$useradd -u 500 -g wheel -m kurobara
</code></p>

<p>以下の表によく使用するオプションを記載します。</p>

<table>
<thead>
<tr>
<th align="left">オプション</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">c コメント      </td>
<td align="left">ユーザーのコメントを設定</td>
</tr>
<tr>
<td align="left">d ディレクトリ  </td>
<td align="left">ユーザーのログインディレクトリを指定</td>
</tr>
<tr>
<td align="left">e mm/dd/yy </td>
<td align="left">ユーザーの有効期限をmm/dd/yy形式で指定</td>
</tr>
<tr>
<td align="left">g グループ   </td>
<td align="left">ユーザーの所属するイニシャル・グループを指定</td>
</tr>
<tr>
<td align="left">G グループ    </td>
<td align="left">ユーザーの所属するグループを指定します(「,」で複数指定可能)</td>
</tr>
<tr>
<td align="left">u ユーザーID </td>
<td align="left">ユーザーのユーザーIDを指定</td>
</tr>
<tr>
<td align="left">s シェル </td>
<td align="left">ユーザーのログインシェルを指定</td>
</tr>
<tr>
<td align="left">m        </td>
<td align="left">ホームディレクトリの作成を自動で行う</td>
</tr>
</tbody>
</table>


<h3>ユーザーアカウントの削除</h3>

<hr />

<p>以下のコマンドでユーザーアカウントの削除ができます。<br/>
なお、オプションにrを付与すると、ホームディレクトリまで削除してくれます。<br/>
但し、他のファイルシステムにあるファイル等は探しだして手動で削除する必要があります。</p>

<p><code>
$userdel &lt;ユーザーアカウント名&gt;
</code></p>

<p>常識ですね(ぉぃ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[コマンドで暗号化Zipファイルを作成する]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/04/22/zip-pass/"/>
    <updated>2013-04-22T23:48:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/04/22/zip-pass</id>
    <content type="html"><![CDATA[<h3>暗号化Zipファイル作成</h3>

<hr />

<p>大概GUIありのツールでやってしまうのですが、必要に駆られたのでコマンドでやることになりました。<br/>
以下のようにzipコマンドのeオプションを使うだけで簡単にできます。</p>

<p><code>
$zip -e &lt;zipファイル名&gt; &lt;圧縮対象のファイル&gt;
</code></p>

<p>恥ずかしながらあんまりやらないので、いざというときには忘れてしまいます。</p>
]]></content>
  </entry>
  
</feed>
