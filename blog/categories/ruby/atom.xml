<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | kurobaraのブログ]]></title>
  <link href="http://moonstruckdrops.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://moonstruckdrops.github.com/"/>
  <updated>2015-06-21T14:58:00+09:00</updated>
  <id>http://moonstruckdrops.github.com/</id>
  <author>
    <name><![CDATA[kurobara]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Railsのモデル周りのマイグレーション]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2015/06/21/rails-migration-command/"/>
    <updated>2015-06-21T14:15:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2015/06/21/rails-migration-command</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<hr />

<p>Railsでmigrationするときにいつもアレなんだっけなぁとなることが多いので、<br/>
備忘録程度にまとめておく</p>

<p>こんなものドキュメント見れば理解できるので、ざっくりレベルのサマリー程度にしておく</p>

<h3>基本</h3>

<hr />

<p>マイグレーションファイル作成コマンド</p>

<p><code>
$rails generate migration クラス名
</code></p>

<p>モデル作成</p>

<p><code>
$rails generate model モデル名
</code></p>

<h3>モデル&amp;テーブル作成</h3>

<hr />

<p>フィールド指定で作成する場合、以下の形で行う<br/>
(大体はフィールド指定を行わずに、実行することが多いかも)</p>

<p><code>
$rails g model モデル名 フィールド:型
</code></p>

<h3>カラムの型指定</h3>

<hr />

<p>細かい調整をしようと思えばできるけど、一旦これだけ覚えておけば良い</p>

<table>
<thead>
<tr>
<th align="left">Ruby側の型 </th>
<th align="left"> DB側の型</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> string </td>
<td align="left"> 文字列</td>
</tr>
<tr>
<td align="left"> text </td>
<td align="left"> 長い文字列</td>
</tr>
<tr>
<td align="left"> integer </td>
<td align="left"> 整数</td>
</tr>
<tr>
<td align="left"> float </td>
<td align="left"> 浮動小数</td>
</tr>
<tr>
<td align="left"> decimal </td>
<td align="left"> 精度の高い小数</td>
</tr>
<tr>
<td align="left"> datetime </td>
<td align="left"> 日時</td>
</tr>
<tr>
<td align="left"> timestamp </td>
<td align="left"> タイムスタンプ</td>
</tr>
<tr>
<td align="left"> time </td>
<td align="left"> 時間</td>
</tr>
<tr>
<td align="left"> date </td>
<td align="left"> 日付</td>
</tr>
<tr>
<td align="left"> binary </td>
<td align="left"> バイナリデータ</td>
</tr>
<tr>
<td align="left"> boolean </td>
<td align="left"> Boolean</td>
</tr>
</tbody>
</table>


<h3>(補足)MySQLで使用する場合の文字列型</h3>

<hr />

<p>MySQLで使用できる文字列型は以下が存在している</p>

<table>
<thead>
<tr>
<th align="left"> DB側の型 </th>
<th align="left"> 内容</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> CHAR </td>
<td align="left"> 255Bまでの固定長文字列</td>
</tr>
<tr>
<td align="left"> VARCHAR </td>
<td align="left"> 64KBまでの可変長文字列</td>
</tr>
<tr>
<td align="left"> TINYTEXT </td>
<td align="left"> 255Bまでの可変長文字列</td>
</tr>
<tr>
<td align="left"> TEXT </td>
<td align="left"> 64KBまでの可変長文字列</td>
</tr>
<tr>
<td align="left"> MEDIUMTEXT </td>
<td align="left"> 約1.6MBまでの可変長文字列</td>
</tr>
<tr>
<td align="left"> LONGTEXT </td>
<td align="left"> 約4.3GBまでの可変長文字列</td>
</tr>
</tbody>
</table>


<p>上記をそれぞれmigrationで利用する場合<br/>
以下のようにlimitをつけることで、使用する文字列型を変更することができる</p>

<p>```
class CreateHoges &lt; ActiveRecord::Migration
  def change</p>

<pre><code>create_table :articles do |t|
  t.text :value, :limit =&gt; 4294967295

  t.timestamps null: false
end
</code></pre>

<p>  end
end
```</p>

<p>実行すると以下のようになる</p>

<p><code>
$ rails db
mysql&gt; show columns from hoges;
+-------------+--------------+------+-----+---------+----------------+
| Field       | Type         | Null | Key | Default | Extra          |
+-------------+--------------+------+-----+---------+----------------+
| id          | int(11)      | NO   | PRI | NULL    | auto_increment |
| value       | longtext     | YES  |     | NULL    |                |
| created_at  | datetime     | NO   |     | NULL    |                |
| updated_at  | datetime     | NO   |     | NULL    |                |
+-------------+--------------+------+-----+---------+----------------+
</code></p>

<p>limitの値は、以下のように対応している</p>

<table>
<thead>
<tr>
<th align="left"> 設定値 </th>
<th align="left"> DB側の型</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> 1 ~ 255 </td>
<td align="left"> TINYTEXT</td>
</tr>
<tr>
<td align="left"> 256 ~ 65535 </td>
<td align="left"> TEXT</td>
</tr>
<tr>
<td align="left"> 65536 ~ 16777215 </td>
<td align="left"> MEDIUMTEXT</td>
</tr>
<tr>
<td align="left"> 16777216 ~ 4294967295 </td>
<td align="left"> LONGTEXT</td>
</tr>
</tbody>
</table>


<h3>マイグレーション実行</h3>

<hr />

<p>DB作成</p>

<p><code>
$rake db:create
</code></p>

<p>マイグレーションの実行</p>

<p><code>
$rake db:migrate
</code></p>

<p>マイグレーション結果確認</p>

<p><code>
$rake db:migrate:status
</code></p>

<p>ロールバック</p>

<p><code>
$rake db:rollback
</code></p>

<p>DBの削除</p>

<p><code>
$rake db:drop
</code></p>

<p>シードの投入(マスターデータなどシードで投入することが多い)</p>

<p><code>
$rake db:seed
</code></p>

<h3>既存カラムの変更</h3>

<hr />

<p>カラムを変更したい場合、以下のコマンドでマイグレーションファイルを生成する</p>

<p><code>
$rails g migration ChangeColumnTo&lt;モデル名&gt;
</code></p>

<p>変更は以下のような形で行う(upとdownを定義することでrollbackにも対応できる)</p>

<p>```
class ChangeColumnToYourModel&lt; ActiveRecord::Migration</p>

<p>  # 変更内容
  def up</p>

<pre><code>change_column :users, :hoge, :string, null: false, default: 0
</code></pre>

<p>  end</p>

<p>  # 変更前の状態
  def down</p>

<pre><code>change_column :users, :hoge, :string, null: true, default: 0
</code></pre>

<p>  end
end
```</p>

<p>気をつけることとして、change_columnは以下のような順で記載すること</p>

<p><code>
change_column :&lt;テーブル名&gt;, :&lt;カラム名&gt;, :&lt;型&gt;, &lt;default値やindexといったオプション指定&gt;
</code></p>

<h3>カラムの追加/削除</h3>

<hr />

<p>カラムの追加/削除をしたい場合、以下のコマンドでマイグレーションファイルを生成する<br/>
追加の場合は、フィールド指定可能</p>

<p><code>
$rails g migration AddColumnTo&lt;モデル&gt;
</code></p>

<p>以下のような形で記載する</p>

<p>```
class AddColumnToYourModel &lt; ActiveRecord::Migration
  def change</p>

<pre><code># 追加
add_column :hoges, :hoge, :string

# 削除
remove_column :hoges, :fuga, :string

# 追加する場所を指定する場合
add_column :hoges, :fugafuga, :string, :after =&gt; :hoge
</code></pre>

<p>  end
end
```</p>

<h3>インデックスの追加/削除</h3>

<hr />

<p>カラムの追加/削除と基本は変わらない</p>

<p><code>
$rails g migration AddIndexTo&lt;モデル&gt;
</code></p>

<p>以下のようにしてindexを設定する</p>

<p>```
class AddIndexToYourModel &lt; ActiveRecord::Migration
  def change</p>

<pre><code># 追加
add_index :hoges, :hoge

# 削除
remove_index :hoges, :fuga

# 複合インデックスの場合
add_index :hoges, [:hoge, :fuga]
</code></pre>

<p>  end
end
```</p>

<h3>参考</h3>

<hr />

<p>ここに書いてる内容は、Railsドキュメント見れば一発で理解できるけどな</p>

<ul>
<li><a href="http://railsdoc.com/model">モデル(model)</a></li>
<li><a href="http://railsdoc.com/migration">マイグレーション(migration)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQueryが見つからないよエラーの解消法]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2014/03/26/update-gemfile/"/>
    <updated>2014-03-26T23:32:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2014/03/26/update-gemfile</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<hr />

<p>今更ながら、Rails3.2のアプリをRails4までアップデートしました。<br/>
そのとき出たエラーと解消方法を残します。</p>

<h3>当該のエラー</h3>

<hr />

<p>それがこれ</p>

<p><code>
couldn't find file 'jquery'
</code></p>

<p>正直、なんで？という感じ</p>

<h3>解消方法</h3>

<hr />

<p>Gemfileの記述が変わってたことが原因でした<br/>
(asset compile周りの仕様変更)</p>

<p>Rails3.x系は、Gemfileに以下がありました</p>

<p>```
group :assets do</p>

<p>ここにasset compileで使用するgemがある</p>

<p>end
```</p>

<p>ところが、Rails4系になるとasset groupは無くなる仕様に変わったみたいです。<br/>
代わりの設定は、<code>config/application.rb</code>になるようです。</p>

<p>メジャーアップデートの前に、<a href="http://railscasts.com/episodes/415-upgrading-to-rails-4?language=ja&amp;view=asciicast">移行ガイド</a>に目を通せってことですねw</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Railsで定数を定義する]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2014/03/23/rails-consts/"/>
    <updated>2014-03-23T20:34:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2014/03/23/rails-consts</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<hr />

<p>Railsで定数を作るとき、いつもどうしてたっけ？っていう個人まとめをつくってみました。</p>

<p>決定版みたいなものが無い感じというのもあったりするので参照用という感じです。</p>

<h3>グローバルな定数定義</h3>

<hr />

<p>以下のような感じの内容で、「config/initializers」に適当なRubyファイルを作成して定義します</p>

<p><code>
HOGE = "HOGE"
FUGA = "FUGA"
</code></p>

<p>もしくは、yamlに定数を切り出して、実行タイミング(Rails起動時)にロードという方式でもいいかもしれません。<br/>
# yamlに切り出すと管理が大変になるかも・・・という欠点は無きにしもあらずですね。</p>

<p>欠点は以下が考えられます。</p>

<ul>
<li>namespaceの概念が無いので少々使いづらい</li>
<li>環境ごとに値を変更したい場合、切り替え処理を自前でやる必要がある</li>
</ul>


<p>特に、環境差分とか無ければこれでいいかもしれませんね。<br/>
# 尤も、namespaceを使わなくて済む程度という前提が付きますが・・・</p>

<h3>コントローラー内で共通な定数定義</h3>

<hr />

<p>以下のような感じで、app/controllers/application_controller.rb 内で定義します</p>

<p><code>
class ApplicationController &lt; ActionController::Base
  HOGE = "HOGE"
  FUGA = "FUGA"
end
</code></p>

<p>単にApplicationControllerがすべてのcontrollerのスーパークラスになっているから参照できるというだけの話です。
# あまりここに定義はしたくないですね。</p>

<h3>rails_configを使って環境ごとに変更する</h3>

<hr />

<p><a href="https://github.com/railsjedi/rails_config">rails_config</a>というgemを使う方法ですね。</p>

<p>以下をGemfileに記述し、インストールします。</p>

<p><code>
gem 'rails_config'
</code></p>

<p>rails_configを使うように初期設定をします(ただのインストールですが)
<code>
$rails g rails_config:install
</code></p>

<p>ファイルに関しては以下の通り</p>

<table>
<thead>
<tr>
<th align="left">環境</th>
<th align="left">ファイルパス</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">全ての環境で共通</td>
<td align="left">config/settings.yml</td>
</tr>
<tr>
<td align="left">ローカル環境</td>
<td align="left">config/settings.local.yml</td>
</tr>
<tr>
<td align="left">開発環境</td>
<td align="left">config/settings/development.yml</td>
</tr>
<tr>
<td align="left">テスト環境</td>
<td align="left">config/settings/test.yml</td>
</tr>
<tr>
<td align="left">本番環境</td>
<td align="left">config/settings/production.yml</td>
</tr>
</tbody>
</table>


<p>YAMLの記述は以下のような感じで行います</p>

<p><code>
hoge:
  fuga: 'fugafuga'
  test: 'test'
</code></p>

<p>使用する場合は、以下のようなコードで出来ます。</p>

<p><code>
Settings.hoge[:fuga]
Settings.hoge['fuga']
Settings[:hoge][:fuga]
</code></p>

<p>他に、同じようなことをする有名なgemに、「settingslogic」があります。<br/>
以下の感想でsettingslogicはあまりつかわないです。</p>

<ul>
<li>一つのファイルで全て定義なのでファイルが肥大化しそう</li>
<li>クラス定義も作る必要があるので若干面倒(シンプルに使えない)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyでSolrを使うときに気をつけること]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2014/03/23/ruby-solr/"/>
    <updated>2014-03-23T12:31:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2014/03/23/ruby-solr</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<hr />

<p>タイトルは釣り臭が半端ないですねw</p>

<p>正確なことを言うと使用ライブラリは、<br/>
特性を理解の上で使いましょうということが言いたいだけです</p>

<h3>RubyでSolrを使う際のライブラリと言えば</h3>

<hr />

<p>大体、以下の２つになると思います</p>

<ul>
<li><a href="https://github.com/rsolr/rsolr">RSolr</a></li>
<li><a href="http://sunspot.github.io/">sunspot</a></li>
</ul>


<p>前者は、シンプルな機能に対して、後者は多機能になっています</p>

<h3>RSolr</h3>

<hr />

<p>ここら編は、ドキュメントを見たほうがよいですが自分の理解をダラっと</p>

<ul>
<li>接続やプロキシは、自分で設定できる(タイムアウトやリトライ設定も可能)</li>
<li>上記の為、(実装に応じるが)自由に検索先のスキーマを変更できる</li>
<li>検索クエリ(ファセットクエリ等も含む)は自前で実装しないといけない</li>
<li>rowsやstartなども自前で実装する必要がある</li>
<li>更新や削除(クエリベースやidベースで)もできる上にメソッドとして用意してある</li>
<li>responseはハッシュになっているので、自前で検索結果を整形(ActiveRecordオブジェクト等)する必要がある</li>
<li>ページングも対応している</li>
</ul>


<p>一声で言うと・・・</p>

<ul>
<li>クエリ構築は自前でやる必要がある</li>
<li>検索結果の整形も自前でやる必要がある</li>
<li>実装次第で、接続先のSolrも自由に変更することができる</li>
</ul>


<p>シンプルとか言っておきながら、結構ありますね<sup>^;;</sup></p>

<p>実際、使うとわかりますがかなりシンプルですよ</p>

<h3>sunspot</h3>

<hr />

<p>こちらもドキュメントを見たほうがよいのですが・・・</p>

<ul>
<li>検索クエリ(facetクエリなら)をDSLライクに記述できる</li>
<li>検索はdismaxで行ってくれる</li>
<li>検索クエリの結果はActiveRecordオブジェクトで取得できる</li>
<li>全文検索も直感的に記述できるうえにboost値も設定できる</li>
<li>ページングやグルーピングにも対応している</li>
<li>緯度、経度のデータも検索できる</li>
<li>検索ハイライトやスキーマデータの結合にも対応している</li>
<li>indexingもsunspotのみで完結することができる(削除もできます)</li>
<li>勿論、手動でクエリを構築することも可能</li>
<li>sunspot自体がRSolrに依存しているので、その気になればRSolrの機能も一応使うことができる</li>
</ul>


<p>これだけ、高機能なので当然の如く欠点もありまして・・・</p>

<ol>
<li>Solrのスキーマ定義がsunspotに依存した形になってしまうこと</li>
<li>indexするデータの一部もsunspotに依存した形になってしまうこと</li>
<li>Solrのフィールドに対応する形でActiveRecordのmodelクラスに定義が必要になること</li>
<li>sunspotが吐き出すクエリを理解しないと使いづらいこと</li>
<li>sunspot自体がmethod_missingを使った実装なのでコードが読みづらいこと・・・</li>
</ol>


<h3>日本語を扱う場合の注意点</h3>

<hr />

<p>基本的に、検索文字列の処理はSolr側のtokenizerで行われます。</p>

<p>ところがsunspotで日本語を使う場合だと、全文字列がエスケープされてしまいます。</p>

<p>例えば、「あいうえお」を検索したい場合だと「\あ\い\う\え\お」になってしまいます。</p>

<p>因みに、英語検索は問題ありません。</p>

<p>原因がどこにあるかと言うと、 <a href="https://github.com/sunspot/sunspot/blob/master/sunspot/lib/sunspot/query/restriction.rb">restriction.rb</a>にあります。</p>

<p>具体的な箇所は、このmodule内で使用されているescapeメソッドが原因です。<br/>
このescapeメソッドの実装は、<a href="https://github.com/rsolr/rsolr/blob/master/lib/rsolr/char.rb">char.rb</a>ですね。<br/>
つまり、RSolr側の不具合に近いでしょう。<br/>
また、RSolrを使って自前で実装するときもこのescapeメソッドを使用しないほうがいいです。</p>

<p>sunspotの依存gem側の問題なので、簡単に修正するのも難しいですね。</p>

<h3>対処方法は？</h3>

<hr />

<p>モンキーパッチを使えば、対処できました。</p>

<p>escapeメソッドを使っているところを全部上書き実装すればいいだけです。</p>

<p>Railsで使う場合だと、「config/initialize/sunspot.rb」みたいなのを作ればいいですね。<br/>
その中で、上記の処理を使えば対応可能です。</p>

<p>まぁ、根本解決ではないなと思いますが・・・</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails(ActiveRecord)でBULK INSERTする方法]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/11/25/ar-bulk-insert/"/>
    <updated>2013-11-25T00:12:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/11/25/ar-bulk-insert</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<hr />

<p>RailsでRake Taskなんか作ったときは、バッチ処理するようなことを書くと思います。<br/>
多分ですが・・・</p>

<p>この前、バルクインサートをすることがあったのでやり方を残しておきます。</p>

<p>因みに、普通にrubyスクリプトの中でも使うこともできると思います(これも多分w)</p>

<h3>やり方</h3>

<hr />

<p><a href="https://github.com/zdennis/activerecord-import/wiki">activerecord-import</a>というGemを使用します。</p>

<p>Gemfileに以下を追加すれば、Rake Taskで使用することができます。<br/>
ぶっちゃけRake Taskだけではなく、普通に使うこともできますが・・・</p>

<p><code>
gem 'activerecord-import'
</code></p>

<p>利用できるデータベースは以下のものです。</p>

<ul>
<li>mysql(アダプターはmysql, mysql2の両方で使用可能)</li>
<li>postgresql</li>
<li>sqlite3</li>
</ul>


<h3>前提</h3>

<hr />

<p>かなり簡単です。</p>

<p>以下のようなモデルを用意したとします。</p>

<ul>
<li>モデル名:Hoge</li>
<li>カラム(主キー): id</li>
<li>カラム(名前): name</li>
<li>カラム(テキスト): text</li>
</ul>


<p>このモデルを10個まとめてバルクインサートしたいとします。</p>

<h3>やり方</h3>

<hr />

<p>かなり簡単です。。。</p>

<ol>
<li>バルクインサートしたい数だけモデルオブジェクトを格納したリストを用意する</li>
<li>該当のモデルのimportメソッドに1で作成したリストを渡す</li>
</ol>


<p>コードに起こすとこんな感じです。。。</p>

<p>```
hoge_list = []
10.times do |i|
  hoge_list &lt;&lt; Hoge.new(id: i, name: "hoge #{i}", text: "fugafuga")
end</p>

<p>Hoge.import hoge_list
```</p>

<p>実行するとこんな感じのSQLが一気に発行されます。。。</p>

<p><code>
INSERT INTO `hoge` (`id`,`name`,`text`,`created_at`,`updated_at`) VALUES (1,'hoge 1','fugafuga','2013-11-25 00:30:30','2013-11-25 00:30:30') ON DUPLICATE KEY UPDATE `messages`.`updated_at`=VALUES(`updated_at`)
INSERT INTO `hoge` (`id`,`name`,`text`,`created_at`,`updated_at`) VALUES (2,'hoge 2','fugafuga','2013-11-25 00:30:30','2013-11-25 00:30:30') ON DUPLICATE KEY UPDATE `messages`.`updated_at`=VALUES(`updated_at`)
</code></p>

<p>因みに、以下のようなオプションがあります。
利用する場合、importメソッドの引数にハッシュで指定するだけです。</p>

<ul>
<li>「:on_duplicate_key_update」: ユニークキーが重複したカラムを更新したい場合に設定</li>
<li>「:timestamps」: falseを設定すると、自分でcreated_at,created_on,update_at,update_onを設定</li>
<li>「:validate」: falseを設定すると、モデル検証をスキップする(デフォルトはtrue)</li>
</ul>


<p>こんな感じで設定します。。。</p>

<p><code>
columns = [:id, :name, :text]
Hoge.import hoge_list, :on_duplicate_key_update =&gt; columns, :timestamps =&gt; false, :validate =&gt; false
</code></p>

<h3>使用感</h3>

<hr />

<p>結構、問題ない感じで使えました。。。</p>

<p>自分が使用した感じだと10万件の更新に1分程度かかったので、<br/>
データが増えていくようなモデル(テーブル)に対して、多用するのは危険かなと思いました。</p>

<p>コードベースで、バルクインサートやバルクアップデートができるところがいいですね。<br/>
データをまとめて引っ張って→データ処理→まとめて更新なんかの使い方では便利かもｗ</p>
]]></content>
  </entry>
  
</feed>
