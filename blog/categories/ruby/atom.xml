<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | kurobaraのブログ]]></title>
  <link href="http://moonstruckdrops.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://moonstruckdrops.github.com/"/>
  <updated>2013-11-12T00:30:44+09:00</updated>
  <id>http://moonstruckdrops.github.com/</id>
  <author>
    <name><![CDATA[kurobara]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ActiveRecordメモ]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/11/12/ar-memo/"/>
    <updated>2013-11-12T00:20:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/11/12/ar-memo</id>
    <content type="html"><![CDATA[<p>使ってるけど、意外と知らなかったのでメモ</p>

<h3>抽出方法は全部同じ</h3>

<hr />

<p>whereの条件指定の方法ですね。</p>

<p>以下の３つは、全て同じSQLを発行します</p>

<p>1.Hashで条件設定する方法(AR独自チックな感じで大体使う方法)</p>

<p><code>
Hoge.where(:title =&gt; "title", :id =&gt; 1)
</code></p>

<p>2.プレースホルダで地道にパラメータ設定する方法(どの言語でも通用する)</p>

<p><code>
Hoge.where("title = ? and id = ?", "title1", 1)
</code></p>

<p>3.シンボルで対応付けをわかりやすくする方法</p>

<p><code>
Hoge.where("title = :title and id = :id", {:title =&gt; "title", :id =&gt;1})
</code></p>

<h3>抽出結果がなかったらレコードの新規作成をする</h3>

<hr />

<p>これ、一発でできるメソッドあったんですね。<br/>
知らなかった。。。</p>

<p>どうやらfirst_or_createというメソッドを使えばよいみたい。<br/>
で、ブロックを取ることができるので、ブロック内で挿入する値を自由に設定できる</p>

<p>以下のような感じで書くとできる模様。</p>

<p>```
Hoge.where(:title => "title").first_or_create do |p|</p>

<pre><code>p.body = "hogehoge"
</code></pre>

<p>end
```</p>

<p>結局は裏で2回SQL発行してるだけなんですけどね。(selectとinsert)</p>

<p>と、まぁ色々とありますがこんなところで。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rubyでアクセス用のメソッドを定義する(アクセッサ)]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/07/25/ruby-accessor/"/>
    <updated>2013-07-25T20:56:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/07/25/ruby-accessor</id>
    <content type="html"><![CDATA[<p>なんてことはない、ただの整理です。</p>

<p>通常インスタンス変数を外部から参照する方法は、インスタンス変数を操作するgetter/setterメソッドを作ります。</p>

<p>Rubyでは、このアクセス用のメソッド(アクセッサ)を簡単に作る機能があります。</p>

<p>以下のようなModuleクラスにあるものを使います</p>

<ul>
<li>attr_reader : 参照(読み出し)できるようにする(getter)</li>
<li>attr_writer : 代入(書き込み)できるようにする(setter)</li>
<li>attr_accessor : 参照、代入の両方できるようにする(getter/setter)</li>
</ul>


<p>それぞれ、使い方は以下のような形になります。</p>

<p>```
class Accessor</p>

<pre><code>attr_reader :name,:hoge
attr_writer :fuga,:piyo
attr_accessor :access

def initialize
    @name = "kurobara"
    @hoge = "hogehoge"
    @fuga = "fugafuga"
    @piyo = "piypiyo"
    @access = "OK"
end

def print_fuga_piyo
    p '---------------------'
    puts "fuga = " + @fuga
    puts "piyo = " + @piyo
end
</code></pre>

<p>end</p>

<p>a = Accessor.new()
puts a.name
puts a.hoge<br/>
a.print_fuga_piyo
p "代入操作"
a.fuga = "fuga2fuga2"
a.piyo = "piyo2piyo2"
a.print_fuga_piyo
p '---------------------'
puts 'a.access = ' + a.access
p "代入操作"
a.access = "OKOK"
puts 'a.access = ' + a.access
```</p>

<p>こんな感じで使えちゃいます。。。<br/>
今更初心者みたいなことしてんなって突っ込まれそうだけど・・・<br/>
attr_accessorばっかり使うので、attr_reader,att_writerを忘れてましたｗ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyでSingletonパターンを実装する]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/07/25/ruby-singleton/"/>
    <updated>2013-07-25T18:33:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/07/25/ruby-singleton</id>
    <content type="html"><![CDATA[<p>このまえ、友人とデザインパターンの話をしてたような気がするので書いてみた。</p>

<p>SingletonはGOFのデザインパターンの一つです。<br/>
使い所は、システム内で絶対に一つにしておかないといけないもの仕組みのものに使います。<br/>
例えば、アプリの設定とか見た目(Look&amp;Feel)とかシステムの何かを管理するだとかに使ったりします。</p>

<p>Singletonは以下の条件を満たす必要があります。</p>

<ul>
<li>作成したクラスのインスタンスは一つだけであることが保証されている</li>
<li>コード上のどこからでも、生成した1つだけのインスタンスにアクセスできる</li>
</ul>


<p>Javaで上の条件を満たすものはこんな感じ</p>

<p>```
final class Singleton {</p>

<pre><code>private static Singleton instance;
private Singleton(){};

public static synchronized Singleton getInstance(){
    if(instance == null){
        instance = new Singleton();
    }
    return instance;
}
</code></pre>

<p>}
```</p>

<p>これと同じ実装をRubyでやるとこんな感じになります。</p>

<p>```
class Singleton
  @@singleton_obj = nil
  @@count = 0</p>

<p>  # 以下の行をコメントアウトすると
  # オブジェクトが再生成されるので
  # シングルトンにならない
  private_class_method:new</p>

<p>  def initialize</p>

<pre><code>@@count = 1
</code></pre>

<p>  end</p>

<p>  def self.get_instance</p>

<pre><code>if @@singleton_obj == nil
  @@singleton_obj = new
end
@@singleton_obj
</code></pre>

<p>  end</p>

<p>  def self.count_up</p>

<pre><code>@@count+=1
</code></pre>

<p>  end</p>

<p>  def self.print_count</p>

<pre><code>p @@count
</code></pre>

<p>  end</p>

<p>end</p>

<p>p '-----------------------'
p '初回インスタンス取得'
p Singleton.get_instance
Singleton.print_count
p '-----------------------'
p '２回目のインスタンス取得でオブジェクトに変更がない'
p Singleton.get_instance
Singleton.count_up
Singleton.print_count
p '-----------------------'
p 'newするとエラーが飛ぶ'
begin
  Singleton.new
rescue
  p 'newでエラーが飛んだ'
end
```</p>

<p>結構長いですねw</p>

<p>上記のコードの実行結果は、以下になります。<br/>
オブジェクトに変化が無いことがわかりますね。<br/>
つまり、オブジェクトが１つであることが、保証されています。</p>

<p>```
"-----------------------"
"初回インスタンス取得"</p>

<h1>&lt;Singleton:0x007f91519026f0></h1>

<p>1
"-----------------------"
"２回目のインスタンス取得でオブジェクトに変更がない"</p>

<h1>&lt;Singleton:0x007f91519026f0></h1>

<p>2
"-----------------------"
"newするとエラーが飛ぶ"
"newでエラーが飛んだ"
```</p>

<p>自力でSingletonを実装すると上記のようなコードなのですが、<br/>
実は、Rubyにはsingletonをやってくれる便利なモジュールがあります。<br/>
これを使うと、Mix-inしたクラスのインスタンスは常に同じものを返してくれます。</p>

<p>```
require 'singleton'</p>

<p>class MySingleton</p>

<p>  include Singleton</p>

<p>  @@count = 0</p>

<p>  def initialize</p>

<pre><code>@@count = 1
</code></pre>

<p>  end</p>

<p>  def self.count_up</p>

<pre><code>@@count+=1
</code></pre>

<p>  end</p>

<p>  def self.print_count</p>

<pre><code>p @@count
</code></pre>

<p>  end
end</p>

<p>p '-----------------------'
p '初回インスタンス取得'
p MySingleton.instance
MySingleton.print_count
p '-----------------------'
p '２回目のインスタンス取得でオブジェクトに変更がない'
p MySingleton.instance
MySingleton.count_up
MySingleton.print_count
p '-----------------------'
p 'newするとエラーが飛ぶ'
begin
  MySingleton.new
rescue
  p 'newでエラーが飛んだ'
end
```</p>

<p>実行結果は、こんな感じ</p>

<p>```
"-----------------------"
"初回インスタンス取得"</p>

<h1>&lt;MySingleton:0x007fd2fa8c9658></h1>

<p>1
"-----------------------"
"２回目のインスタンス取得でオブジェクトに変更がない"</p>

<h1>&lt;MySingleton:0x007fd2fa8c9658></h1>

<p>2
"-----------------------"
"newするとエラーが飛ぶ"
"newでエラーが飛んだ"
```</p>

<p>モジュールを使うと、スッキリとしたコードになりますね。<br/>
当たり前ですが、newしようとするとエラーになります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyのStructクラスが便利]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/07/02/ruby-struct/"/>
    <updated>2013-07-02T01:15:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/07/02/ruby-struct</id>
    <content type="html"><![CDATA[<p>特にちょっとしたデータ構造を作成したいときなんかは非常に有効な手段かも</p>

<h3>Structクラス</h3>

<hr />

<p>Rubyの組み込みクラスです。(Classに比べて影が薄いですが・・・)</p>

<p>平たく言うと、Classクラスに似ているものです。</p>

<p>じゃー違いは何なの？ってなります。</p>

<ol>
<li>newしたとき、引数で指定したアクnセッサをもつクラスを生成する</li>
<li>第一引数の文字列がクラス名となるが、指定がない場合は無名のクラスになる</li>
</ol>


<p>これだけ。</p>

<p><code>
Point = Struct.new("Point", :x, :y)
item = Point.new(100,200)
p item =&gt; #&lt;struct Struct::Point x=100, y=200&gt;
p item.x =&gt; 100
</code></p>

<p>無名クラスだと、こんな感じ</p>

<p><code>
Point2 = Struct.new(:z)
Point2.class =&gt; Class
item2 = Point2.new(300)
p item2 =&gt; #&lt;struct Point2 z=300&gt;
</code></p>

<h3>ドキュメントに無い機能</h3>

<hr />

<p>ブロックを使うことができることです。<br/>
ブロック内では、独自のメソッドを定義することができます。</p>

<p>こんな感じです。</p>

<p>```
Point = Struct.new(:x, :y) do
  def sum</p>

<pre><code>    x + y
</code></pre>

<p>  end</p>

<p>  def minus</p>

<pre><code>    x - y 
</code></pre>

<p>  end
end
p Point.new(600, 700).sum => 1300
p Point.new(800,900).minus => -100
```</p>

<p>他にも、superを使うことで、上位のコンストラクタを実行することができます。</p>

<p>```
class Point &lt; Struct.new(:x, :y)
  def initialize(x, y)</p>

<pre><code>z = x + y
super(z, y)
</code></pre>

<p>  end
end</p>

<p>item = Point.new(400, 500)
p item => #<struct Point x=900, y=500>
```</p>

<h3>使いどころ</h3>

<hr />

<p>正直、あんまり無いような気がしなくもないですが、自分だと以下で使います。</p>

<ul>
<li>csvファイルとか読み込むとき、ちょっとしたデータ構造を定義するとき</li>
<li>ちょっとしたデータのソート</li>
<li>ちょっとしたアルゴリズムの追加</li>
<li>ハッシュの代わりとか(既にデータ構造が分かってる場合など)</li>
</ul>


<p>データソートする場合の例</p>

<p>```
class Point &lt; Struct.new(:x, :y)
  def initialize(x, y)</p>

<pre><code>z = x + y
super(z, y)
</code></pre>

<p>  end
end</p>

<p>item = Point.new(400, 500)
item2 = Point.new(200,300)</p>

<p>p item => #<struct Point x=900, y=500>
p item2 => #<struct Point x=500, y=300></p>

<p>array = []
array &lt;&lt; item
array &lt;&lt; item2</p>

<p>p array => [#<struct Point x=900, y=500>, #<struct Point x=500, y=300>]</p>

<p>result = array.sort{ |item1,item2|</p>

<pre><code>                item1.x &lt;=&gt; item2.x
           }
</code></pre>

<p>p result => [#<struct Point x=500, y=300>, #<struct Point x=900, y=500>]
```</p>

<p>書き捨てみたいなRubyコードを書くときにはちょうどいいのかもしれないですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rubymineを使ってみる]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/06/08/use-rubymine/"/>
    <updated>2013-06-08T17:26:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/06/08/use-rubymine</id>
    <content type="html"><![CDATA[<p>皆さんはRubyやRailsでアプリを書くときどのようなエディタを使いますでしょうか？</p>

<h6>僕は、Emacsで書いていることが多いです。。。</h6>

<p>多いのですが・・・<br/>
こんな感じで若干面倒な面もあってですね。</p>

<ul>
<li>設定がともかく面倒くさい・・・。</li>
<li>色々設定を追加しているので、重くなってきた(僕の設定が悪いのかもしれませんが・・・)</li>
<li>補完周りも効くのか効かないのか微妙な時も(僕の設定が悪いry)</li>
<li>オムニ補完が・・・効きすぎてお節介すぎる(僕の設定がry)</li>
<li>その他色々。。。</li>
</ul>


<p>良い面もありまして、僕が思う良い面はこんな感じ。</p>

<ul>
<li>キーバインドがカスタムできるよ</li>
<li>画面が分割できるので、TDDにも向いてるよ</li>
<li>オムニ補完が良い感じに効いたときは、さくさくコードが書ける</li>
<li>タブやフォーマットとか「{ }」の自動補完とかきっちりやってくれる</li>
<li>あとは、タグを使ってソースからソースへのコードジャンプができる</li>
</ul>


<p>殆ど、Emacsの機能ですねw</p>

<p>で、面倒くさい面もあるのでRuby開発に限ってはEmacsを卒業してもいいのではないかと最近思うようになりました。</p>

<p>なので、Rubyをスムーズに開発できるエディタってなんだろうとか気になりだした訳です。<br/>
エディタとして候補が挙げれたものは・・・</p>

<ul>
<li>Vim</li>
<li>Text Mate</li>
<li>Sublime text2</li>
<li>Coda</li>
<li>Aptana Studio(Eclipse)</li>
<li>RubyMine</li>
</ul>


<p>自分が観測できた範囲だとこんだけ。</p>

<p>色々ありますね。とりかえず今回はRubyMineを使ってみます。</p>

<h6>Rails コマンド</h6>

<p>「$rails migration」とか実行する場合、「Ctrl + Option + G」<br/>
よく使いそうなものは大体実行できます。<br/>
主に以下のようなことができる。(ここでは一部のみ記載)</p>

<ul>
<li>scaffold</li>
<li>migration</li>
<li>helper</li>
<li>controller</li>
<li>その他色々</li>
</ul>


<h6>Rails Server</h6>

<p>サーバを起動する場合、「Option + Shift + F10」<br/>
デバッグ実行やプロダクション起動、リリース</p>

<h6>リファクタリング</h6>

<p>変更箇所をカーソルで選択後「Shift + F6」<br/>
プレビューが表示されるので、「Do Refactor」を実行しましょう。<br/>
いちいち、「Do Refactor」ボタンを押さないといけないところに操作性のムカツキを感じる。</p>

<h6>その他</h6>

<p>エディタ自身の設定でデフォルトで有効になっている「フリーカーソール」をOFFにしたい。(余白をクリックすると、行の末尾にいかない)<br/>
設定項目のエディタ設定で、「Vertual Space」を見つけます。</p>

<h6>「Allow Placement of caret after the end of line」のチェックボックスを外します。</h6>

<p>そうすると、余白をクリックしても行の末尾にいくようになります</p>
]]></content>
  </entry>
  
</feed>
