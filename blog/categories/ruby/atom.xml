<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | kurobaraのブログ]]></title>
  <link href="http://moonstruckdrops.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://moonstruckdrops.github.com/"/>
  <updated>2013-10-29T01:21:32+09:00</updated>
  <id>http://moonstruckdrops.github.com/</id>
  <author>
    <name><![CDATA[kurobara]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rubyでアクセス用のメソッドを定義する(アクセッサ)]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/07/25/ruby-accessor/"/>
    <updated>2013-07-25T20:56:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/07/25/ruby-accessor</id>
    <content type="html"><![CDATA[<p>なんてことはない、ただの整理です。</p>

<p>通常インスタンス変数を外部から参照する方法は、インスタンス変数を操作するgetter/setterメソッドを作ります。</p>

<p>Rubyでは、このアクセス用のメソッド(アクセッサ)を簡単に作る機能があります。</p>

<p>以下のようなModuleクラスにあるものを使います</p>

<ul>
<li>attr_reader : 参照(読み出し)できるようにする(getter)</li>
<li>attr_writer : 代入(書き込み)できるようにする(setter)</li>
<li>attr_accessor : 参照、代入の両方できるようにする(getter/setter)</li>
</ul>


<p>それぞれ、使い方は以下のような形になります。</p>

<p>```
class Accessor</p>

<pre><code>attr_reader :name,:hoge
attr_writer :fuga,:piyo
attr_accessor :access

def initialize
    @name = "kurobara"
    @hoge = "hogehoge"
    @fuga = "fugafuga"
    @piyo = "piypiyo"
    @access = "OK"
end

def print_fuga_piyo
    p '---------------------'
    puts "fuga = " + @fuga
    puts "piyo = " + @piyo
end
</code></pre>

<p>end</p>

<p>a = Accessor.new()
puts a.name
puts a.hoge<br/>
a.print_fuga_piyo
p "代入操作"
a.fuga = "fuga2fuga2"
a.piyo = "piyo2piyo2"
a.print_fuga_piyo
p '---------------------'
puts 'a.access = ' + a.access
p "代入操作"
a.access = "OKOK"
puts 'a.access = ' + a.access
```</p>

<p>こんな感じで使えちゃいます。。。<br/>
今更初心者みたいなことしてんなって突っ込まれそうだけど・・・<br/>
attr_accessorばっかり使うので、attr_reader,att_writerを忘れてましたｗ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyでSingletonパターンを実装する]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/07/25/ruby-singleton/"/>
    <updated>2013-07-25T18:33:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/07/25/ruby-singleton</id>
    <content type="html"><![CDATA[<p>このまえ、友人とデザインパターンの話をしてたような気がするので書いてみた。</p>

<p>SingletonはGOFのデザインパターンの一つです。<br/>
使い所は、システム内で絶対に一つにしておかないといけないもの仕組みのものに使います。<br/>
例えば、アプリの設定とか見た目(Look&amp;Feel)とかシステムの何かを管理するだとかに使ったりします。</p>

<p>Singletonは以下の条件を満たす必要があります。</p>

<ul>
<li>作成したクラスのインスタンスは一つだけであることが保証されている</li>
<li>コード上のどこからでも、生成した1つだけのインスタンスにアクセスできる</li>
</ul>


<p>Javaで上の条件を満たすものはこんな感じ</p>

<p>```
final class Singleton {</p>

<pre><code>private static Singleton instance;
private Singleton(){};

public static synchronized Singleton getInstance(){
    if(instance == null){
        instance = new Singleton();
    }
    return instance;
}
</code></pre>

<p>}
```</p>

<p>これと同じ実装をRubyでやるとこんな感じになります。</p>

<p>```
class Singleton
  @@singleton_obj = nil
  @@count = 0</p>

<p>  # 以下の行をコメントアウトすると
  # オブジェクトが再生成されるので
  # シングルトンにならない
  private_class_method:new</p>

<p>  def initialize</p>

<pre><code>@@count = 1
</code></pre>

<p>  end</p>

<p>  def self.get_instance</p>

<pre><code>if @@singleton_obj == nil
  @@singleton_obj = new
end
@@singleton_obj
</code></pre>

<p>  end</p>

<p>  def self.count_up</p>

<pre><code>@@count+=1
</code></pre>

<p>  end</p>

<p>  def self.print_count</p>

<pre><code>p @@count
</code></pre>

<p>  end</p>

<p>end</p>

<p>p '-----------------------'
p '初回インスタンス取得'
p Singleton.get_instance
Singleton.print_count
p '-----------------------'
p '２回目のインスタンス取得でオブジェクトに変更がない'
p Singleton.get_instance
Singleton.count_up
Singleton.print_count
p '-----------------------'
p 'newするとエラーが飛ぶ'
begin
  Singleton.new
rescue
  p 'newでエラーが飛んだ'
end
```</p>

<p>結構長いですねw</p>

<p>上記のコードの実行結果は、以下になります。<br/>
オブジェクトに変化が無いことがわかりますね。<br/>
つまり、オブジェクトが１つであることが、保証されています。</p>

<p>```
"-----------------------"
"初回インスタンス取得"</p>

<h1>&lt;Singleton:0x007f91519026f0></h1>

<p>1
"-----------------------"
"２回目のインスタンス取得でオブジェクトに変更がない"</p>

<h1>&lt;Singleton:0x007f91519026f0></h1>

<p>2
"-----------------------"
"newするとエラーが飛ぶ"
"newでエラーが飛んだ"
```</p>

<p>自力でSingletonを実装すると上記のようなコードなのですが、<br/>
実は、Rubyにはsingletonをやってくれる便利なモジュールがあります。<br/>
これを使うと、Mix-inしたクラスのインスタンスは常に同じものを返してくれます。</p>

<p>```
require 'singleton'</p>

<p>class MySingleton</p>

<p>  include Singleton</p>

<p>  @@count = 0</p>

<p>  def initialize</p>

<pre><code>@@count = 1
</code></pre>

<p>  end</p>

<p>  def self.count_up</p>

<pre><code>@@count+=1
</code></pre>

<p>  end</p>

<p>  def self.print_count</p>

<pre><code>p @@count
</code></pre>

<p>  end
end</p>

<p>p '-----------------------'
p '初回インスタンス取得'
p MySingleton.instance
MySingleton.print_count
p '-----------------------'
p '２回目のインスタンス取得でオブジェクトに変更がない'
p MySingleton.instance
MySingleton.count_up
MySingleton.print_count
p '-----------------------'
p 'newするとエラーが飛ぶ'
begin
  MySingleton.new
rescue
  p 'newでエラーが飛んだ'
end
```</p>

<p>実行結果は、こんな感じ</p>

<p>```
"-----------------------"
"初回インスタンス取得"</p>

<h1>&lt;MySingleton:0x007fd2fa8c9658></h1>

<p>1
"-----------------------"
"２回目のインスタンス取得でオブジェクトに変更がない"</p>

<h1>&lt;MySingleton:0x007fd2fa8c9658></h1>

<p>2
"-----------------------"
"newするとエラーが飛ぶ"
"newでエラーが飛んだ"
```</p>

<p>モジュールを使うと、スッキリとしたコードになりますね。<br/>
当たり前ですが、newしようとするとエラーになります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyのStructクラスが便利]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/07/02/ruby-struct/"/>
    <updated>2013-07-02T01:15:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/07/02/ruby-struct</id>
    <content type="html"><![CDATA[<p>特にちょっとしたデータ構造を作成したいときなんかは非常に有効な手段かも</p>

<h3>Structクラス</h3>

<hr />

<p>Rubyの組み込みクラスです。(Classに比べて影が薄いですが・・・)</p>

<p>平たく言うと、Classクラスに似ているものです。</p>

<p>じゃー違いは何なの？ってなります。</p>

<ol>
<li>newしたとき、引数で指定したアクnセッサをもつクラスを生成する</li>
<li>第一引数の文字列がクラス名となるが、指定がない場合は無名のクラスになる</li>
</ol>


<p>これだけ。</p>

<p><code>
Point = Struct.new("Point", :x, :y)
item = Point.new(100,200)
p item =&gt; #&lt;struct Struct::Point x=100, y=200&gt;
p item.x =&gt; 100
</code></p>

<p>無名クラスだと、こんな感じ</p>

<p><code>
Point2 = Struct.new(:z)
Point2.class =&gt; Class
item2 = Point2.new(300)
p item2 =&gt; #&lt;struct Point2 z=300&gt;
</code></p>

<h3>ドキュメントに無い機能</h3>

<hr />

<p>ブロックを使うことができることです。<br/>
ブロック内では、独自のメソッドを定義することができます。</p>

<p>こんな感じです。</p>

<p>```
Point = Struct.new(:x, :y) do
  def sum</p>

<pre><code>    x + y
</code></pre>

<p>  end</p>

<p>  def minus</p>

<pre><code>    x - y 
</code></pre>

<p>  end
end
p Point.new(600, 700).sum => 1300
p Point.new(800,900).minus => -100
```</p>

<p>他にも、superを使うことで、上位のコンストラクタを実行することができます。</p>

<p>```
class Point &lt; Struct.new(:x, :y)
  def initialize(x, y)</p>

<pre><code>z = x + y
super(z, y)
</code></pre>

<p>  end
end</p>

<p>item = Point.new(400, 500)
p item => #<struct Point x=900, y=500>
```</p>

<h3>使いどころ</h3>

<hr />

<p>正直、あんまり無いような気がしなくもないですが、自分だと以下で使います。</p>

<ul>
<li>csvファイルとか読み込むとき、ちょっとしたデータ構造を定義するとき</li>
<li>ちょっとしたデータのソート</li>
<li>ちょっとしたアルゴリズムの追加</li>
<li>ハッシュの代わりとか(既にデータ構造が分かってる場合など)</li>
</ul>


<p>データソートする場合の例</p>

<p>```
class Point &lt; Struct.new(:x, :y)
  def initialize(x, y)</p>

<pre><code>z = x + y
super(z, y)
</code></pre>

<p>  end
end</p>

<p>item = Point.new(400, 500)
item2 = Point.new(200,300)</p>

<p>p item => #<struct Point x=900, y=500>
p item2 => #<struct Point x=500, y=300></p>

<p>array = []
array &lt;&lt; item
array &lt;&lt; item2</p>

<p>p array => [#<struct Point x=900, y=500>, #<struct Point x=500, y=300>]</p>

<p>result = array.sort{ |item1,item2|</p>

<pre><code>                item1.x &lt;=&gt; item2.x
           }
</code></pre>

<p>p result => [#<struct Point x=500, y=300>, #<struct Point x=900, y=500>]
```</p>

<p>書き捨てみたいなRubyコードを書くときにはちょうどいいのかもしれないですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rubymineを使ってみる]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/06/08/use-rubymine/"/>
    <updated>2013-06-08T17:26:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/06/08/use-rubymine</id>
    <content type="html"><![CDATA[<p>皆さんはRubyやRailsでアプリを書くときどのようなエディタを使いますでしょうか？</p>

<h6>僕は、Emacsで書いていることが多いです。。。</h6>

<p>多いのですが・・・<br/>
こんな感じで若干面倒な面もあってですね。</p>

<ul>
<li>設定がともかく面倒くさい・・・。</li>
<li>色々設定を追加しているので、重くなってきた(僕の設定が悪いのかもしれませんが・・・)</li>
<li>補完周りも効くのか効かないのか微妙な時も(僕の設定が悪いry)</li>
<li>オムニ補完が・・・効きすぎてお節介すぎる(僕の設定がry)</li>
<li>その他色々。。。</li>
</ul>


<p>良い面もありまして、僕が思う良い面はこんな感じ。</p>

<ul>
<li>キーバインドがカスタムできるよ</li>
<li>画面が分割できるので、TDDにも向いてるよ</li>
<li>オムニ補完が良い感じに効いたときは、さくさくコードが書ける</li>
<li>タブやフォーマットとか「{ }」の自動補完とかきっちりやってくれる</li>
<li>あとは、タグを使ってソースからソースへのコードジャンプができる</li>
</ul>


<p>殆ど、Emacsの機能ですねw</p>

<p>で、面倒くさい面もあるのでRuby開発に限ってはEmacsを卒業してもいいのではないかと最近思うようになりました。</p>

<p>なので、Rubyをスムーズに開発できるエディタってなんだろうとか気になりだした訳です。<br/>
エディタとして候補が挙げれたものは・・・</p>

<ul>
<li>Vim</li>
<li>Text Mate</li>
<li>Sublime text2</li>
<li>Coda</li>
<li>Aptana Studio(Eclipse)</li>
<li>RubyMine</li>
</ul>


<p>自分が観測できた範囲だとこんだけ。</p>

<p>色々ありますね。とりかえず今回はRubyMineを使ってみます。</p>

<h6>Rails コマンド</h6>

<p>「$rails migration」とか実行する場合、「Ctrl + Option + G」<br/>
よく使いそうなものは大体実行できます。<br/>
主に以下のようなことができる。(ここでは一部のみ記載)</p>

<ul>
<li>scaffold</li>
<li>migration</li>
<li>helper</li>
<li>controller</li>
<li>その他色々</li>
</ul>


<h6>Rails Server</h6>

<p>サーバを起動する場合、「Option + Shift + F10」<br/>
デバッグ実行やプロダクション起動、リリース</p>

<h6>リファクタリング</h6>

<p>変更箇所をカーソルで選択後「Shift + F6」<br/>
プレビューが表示されるので、「Do Refactor」を実行しましょう。<br/>
いちいち、「Do Refactor」ボタンを押さないといけないところに操作性のムカツキを感じる。</p>

<h6>その他</h6>

<p>エディタ自身の設定でデフォルトで有効になっている「フリーカーソール」をOFFにしたい。(余白をクリックすると、行の末尾にいかない)<br/>
設定項目のエディタ設定で、「Vertual Space」を見つけます。</p>

<h6>「Allow Placement of caret after the end of line」のチェックボックスを外します。</h6>

<p>そうすると、余白をクリックしても行の末尾にいくようになります</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[万葉.rbに参加してきました。#everyrb]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/04/06/ranyo-rb/"/>
    <updated>2013-04-06T13:01:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/04/06/ranyo-rb</id>
    <content type="html"><![CDATA[<p>参加メモメモ。</p>

<h3>オープニング</h3>

<hr />

<p>Matzからの挨拶。<br/>
楽しい設計の言語が真面目に仕事になって嬉しい。<br/>
万葉をよろしく!!</p>

<h3>基調公演(島田さん)</h3>

<hr />

<p>言葉は軽く聞こえるけど、会社経営だとすごい!!</p>

<p>最近思う「コミュニティと会社の私」</p>

<ul>
<li>会社は孤立している。契約とか仕事程度(内側のつながりはない)</li>
<li>コミュニティではゆるく繋がっているので、今は繋がっているのではないのか</li>
<li>Rubyのコミュニティは面白い方々多い</li>
<li>地域Ruby会議に行くと、質問したり自分のことを見直すきっかけになるのでいいかもしれない</li>
<li>普通、ビジネス主体としての会社</li>
<li>もう１つは、コミュニティとしての会社</li>
<li>中の人が見えるというのはいい</li>
</ul>


<h3>万葉社長</h3>

<hr />

<p>コードについて言いたいこと</p>

<p>プログラミングはどういう仕事？</p>

<p>良い考えが最良とは限らない(衝突が起きる)</p>

<ul>
<li>クラス名が仕様書番号とか最低すぎる</li>
<li>わかりやすい名前</li>
<li>自動テストあるといいよ</li>
<li>PHP悪くてRubyがいいという意見は、別れる</li>
<li>MVCとオブジェクト指向は？</li>
<li>DRYと読みやすさ</li>
<li>RDB的に最適解とオブジェクト指向</li>
<li>安全と自由(型など)</li>
</ul>


<p>そのため、一般的に悪いといわれることが役立つこともある。</p>

<p>他にも・・・</p>

<ul>
<li>すべてを一気に解決することはできない。</li>
<li>どの局面で問題を解決をするのが重要</li>
<li>正解なんてものはない。</li>
</ul>


<p>大事なこと</p>

<ul>
<li>意思の表明。思ってるだけでは何もできない</li>
<li>考えていることを言語化することが必要</li>
<li>たのしくソフトウェア開発ができること</li>
<li>意思をもって選びとること</li>
</ul>


<h3>LT</h3>

<hr />

<p>角谷さん</p>

<ul>
<li>Rubyで仕事しだすと会社とコミュニティと個人のつながりを考えだす</li>
<li>WHYから始める</li>
</ul>


<p>和田さん</p>

<ul>
<li>6年続くのはすごい</li>
<li>生き生きできるのはレッドじゃなくてサブ</li>
<li>オススメ本:はじめの一歩を踏み出そう</li>
</ul>


<p>これ以外は聞くほうが面白かったのでメモってません。<br/>
ごめんなさいm(<em> </em>)m</p>

<h3>宿題的なアレ</h3>

<hr />

<p>万葉の中の人にやってること、超面白いし聞きたいんで是非LTやってくださいと勧められました。<br/>
なので、機会があればどこかでネタを話たいなーと思います。</p>

<p># 思ってるだけだとダメなので実際どこかで行動しないといけないですね。</p>
]]></content>
  </entry>
  
</feed>
