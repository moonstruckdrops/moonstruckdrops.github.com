<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | kurobaraのブログ]]></title>
  <link href="http://moonstruckdrops.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://moonstruckdrops.github.com/"/>
  <updated>2014-02-15T22:01:22+09:00</updated>
  <id>http://moonstruckdrops.github.com/</id>
  <author>
    <name><![CDATA[kurobara]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails(ActiveRecord)でBULK INSERTする方法]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/11/25/ar-bulk-insert/"/>
    <updated>2013-11-25T00:12:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/11/25/ar-bulk-insert</id>
    <content type="html"><![CDATA[<h3>はじめに</h3>

<hr />

<p>RailsでRake Taskなんか作ったときは、バッチ処理するようなことを書くと思います。<br/>
多分ですが・・・</p>

<p>この前、バルクインサートをすることがあったのでやり方を残しておきます。</p>

<p>因みに、普通にrubyスクリプトの中でも使うこともできると思います(これも多分w)</p>

<h3>やり方</h3>

<hr />

<p><a href="https://github.com/zdennis/activerecord-import/wiki">activerecord-import</a>というGemを使用します。</p>

<p>Gemfileに以下を追加すれば、Rake Taskで使用することができます。<br/>
ぶっちゃけRake Taskだけではなく、普通に使うこともできますが・・・</p>

<p><code>
gem 'activerecord-import'
</code></p>

<p>利用できるデータベースは以下のものです。</p>

<ul>
<li>mysql(アダプターはmysql, mysql2の両方で使用可能)</li>
<li>postgresql</li>
<li>sqlite3</li>
</ul>


<h3>前提</h3>

<hr />

<p>かなり簡単です。</p>

<p>以下のようなモデルを用意したとします。</p>

<ul>
<li>モデル名:Hoge</li>
<li>カラム(主キー): id</li>
<li>カラム(名前): name</li>
<li>カラム(テキスト): text</li>
</ul>


<p>このモデルを10個まとめてバルクインサートしたいとします。</p>

<h3>やり方</h3>

<hr />

<p>かなり簡単です。。。</p>

<ol>
<li>バルクインサートしたい数だけモデルオブジェクトを格納したリストを用意する</li>
<li>該当のモデルのimportメソッドに1で作成したリストを渡す</li>
</ol>


<p>コードに起こすとこんな感じです。。。</p>

<p>```
hoge_list = []
10.times do |i|
  hoge_list &lt;&lt; Hoge.new(id: i, name: "hoge #{i}", text: "fugafuga")
end</p>

<p>Hoge.import hoge_list
```</p>

<p>実行するとこんな感じのSQLが一気に発行されます。。。</p>

<p><code>
INSERT INTO `hoge` (`id`,`name`,`text`,`created_at`,`updated_at`) VALUES (1,'hoge 1','fugafuga','2013-11-25 00:30:30','2013-11-25 00:30:30') ON DUPLICATE KEY UPDATE `messages`.`updated_at`=VALUES(`updated_at`)
INSERT INTO `hoge` (`id`,`name`,`text`,`created_at`,`updated_at`) VALUES (2,'hoge 2','fugafuga','2013-11-25 00:30:30','2013-11-25 00:30:30') ON DUPLICATE KEY UPDATE `messages`.`updated_at`=VALUES(`updated_at`)
</code></p>

<p>因みに、以下のようなオプションがあります。
利用する場合、importメソッドの引数にハッシュで指定するだけです。</p>

<ul>
<li>「:on_duplicate_key_update」: ユニークキーが重複したカラムを更新したい場合に設定</li>
<li>「:timestamps」: falseを設定すると、自分でcreated_at,created_on,update_at,update_onを設定</li>
<li>「:validate」: falseを設定すると、モデル検証をスキップする(デフォルトはtrue)</li>
</ul>


<p>こんな感じで設定します。。。</p>

<p><code>
columns = [:id, :name, :text]
Hoge.import hoge_list, :on_duplicate_key_update =&gt; columns, :timestamps =&gt; false, :validate =&gt; false
</code></p>

<h3>使用感</h3>

<hr />

<p>結構、問題ない感じで使えました。。。</p>

<p>自分が使用した感じだと10万件の更新に1分程度かかったので、<br/>
データが増えていくようなモデル(テーブル)に対して、多用するのは危険かなと思いました。</p>

<p>コードベースで、バルクインサートやバルクアップデートができるところがいいですね。<br/>
データをまとめて引っ張って→データ処理→まとめて更新なんかの使い方では便利かもｗ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecordメモ その2]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/11/19/ar-memo-2/"/>
    <updated>2013-11-19T00:13:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/11/19/ar-memo-2</id>
    <content type="html"><![CDATA[<p>前回書いたので、メモをまたまた残しておく</p>

<p>今回は、以下の３つを書き起こす。</p>

<ul>
<li>既存行の更新処理</li>
<li>データ保存系メソッドの違い</li>
<li>既存行の削除処理</li>
<li>コールバック</li>
</ul>


<h3>既存行の更新</h3>

<hr />

<p>1.更新する行を特定してから更新するやり方</p>

<p>```
table = Tables.find(12)
table.name = "column name"
table.save</p>

<p>```</p>

<p>2.属性の値を変更してからモデルオブジェクトを取得するやり方</p>

<p><code>
table = Tables.find(12)
table.update_attribute(:name, "column_name")
</code></p>

<p>上はシンボルを使って、特定の１カラムのみの更新の場合</p>

<p>まとめて行を更新する場合、ハッシュを使いますね。</p>

<p><code>
table = Tables.find(12)
table.update_attributes(name: "column_name", text: "ActiveRecord")
</code></p>

<p>因みに、Railsだとこんな感じで使ってますね。</p>

<p>```
def update
  table = Tables.find(params[:id])
  if table.update_attributes(params[:table])</p>

<pre><code>redirect_to action: :index
</code></pre>

<p>  else</p>

<pre><code>redirect_to action: :edit
</code></pre>

<p>  end
end
```</p>

<p>3.行の読み込みと更新を一度に行う方法</p>

<p>これは特に言うこともないですね。<br/>
指定した行を更新し、結果をDBに反映、そのままオブジェクトを取得します</p>

<p><code>
table = Tables.update(12, name: "column_name", text: "ActiveRecord")
</code></p>

<p>因みに、update_allメソッドを使えばまとめて更新することができます。<br/>
第1引数にupdate文、第2引数にwhere句を指定という形でやります。</p>

<p><code>
table = Tbales.update_all("name = column_name, text = ActiveRecord", "id = 12")
</code></p>

<p>戻り値は、データベースのアダプターによって異なるようです。<br/>
大体、更新行数が返るようですが、Oracleだけ何故か違うみたいです。。。</p>

<h3>データ保存系メソッドの違い</h3>

<hr />

<table>
<thead>
<tr>
<th align="left">メソッド </th>
<th align="left"> 違い </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">save    </td>
<td align="left">レコードが保存された場合、trueを返し、そうでなければnilを返す</td>
</tr>
<tr>
<td align="left">save!   </td>
<td align="left">保存が成功した、trueを返し、そうでなければ例外を発生</td>
</tr>
<tr>
<td align="left">create  </td>
<td align="left">保存に成功したかどうかは関係なく、ActiveRecordオブジェクトを返す。データが保存されたかどうかの確認は検証チェックが必要</td>
</tr>
<tr>
<td align="left">create! </td>
<td align="left">成功時は、ActiveRecordオブジェクトを返し、そうでなければ例外を発生</td>
</tr>
</tbody>
</table>


<p>なので、使い分けはこんな感じに行う</p>

<p><code>
if table.save
  検証と保存に成功
else
  検証エラー
end
</code></p>

<p><code>
begin
  table.save!
rescue ActiveRecord::RecordInvalid =&gt; error
  検証エラー
rescue ActiveRecord::RecordNotSaved =&gt; error
  保存に失敗(コールバックで保存が出来なかった)
end
</code></p>

<h3>既存行の削除処理</h3>

<hr />

<p>これは２種類の方法があります。<br/>
１つ目、データベースを直接操作する感じのやり方</p>

<p>こんな感じで、id指定で削除できます。<br/>
idを格納した配列を指定することで、まとめて削除もできます。</p>

<p><code>
Tables.delete(12)
</code></p>

<p>SQLのwhereを使ってまとめて削除する方法</p>

<p><code>
Tables.delete_all(["id = 12"])
</code></p>

<p>これもupdate_allメソッドと同じで削除した行数が返ってきます。</p>

<p>もう一つのやり方は、destroyメソッドを使う方法です。<br/>
こいつは、削除というよりもデータの凍結ですね。</p>

<p>特定の行のみ凍結</p>

<p><code>
Tables.destroy(12)
</code></p>

<p>まとめて凍結する方法</p>

<p><code>
Tables.destroy_all("name = ?", "column_name")
</code></p>

<p>因みにdeleteメソッドを使った場合、<br/>
ActiveRecordの検証メソッドが実行されないことに注意かも。</p>

<h3>コールバック順序</h3>

<hr />

<p>コールバックで独自に処理を入れたい場合ってあると思うので、ついでにメモしておく</p>

<p>新規レコードでmodel.saveを実行した場合、以下の順序でコールバックされる</p>

<ol>
<li>before_validation</li>
<li>検証処理</li>
<li>after_validation</li>
<li>before_save</li>
<li>before_create</li>
<li>挿入処理</li>
<li>after_create</li>
<li>after_save</li>
</ol>


<p>更新の場合だと以下になる</p>

<ol>
<li>before_validation</li>
<li>検証処理</li>
<li>after_validation</li>
<li>before_save</li>
<li>before_update</li>
<li>更新処理</li>
<li>after_update</li>
<li>after_save</li>
</ol>


<p>削除(model.destroy)だと、以下になる</p>

<ol>
<li>before_destroy</li>
<li>destroy処理</li>
<li>after_destory</li>
</ol>


<p>ここまでそれなりに書いたので、もうちょい参照系も書いておきたいなw</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecordメモ]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/11/12/ar-memo/"/>
    <updated>2013-11-12T00:20:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/11/12/ar-memo</id>
    <content type="html"><![CDATA[<p>使ってるけど、意外と知らなかったのでメモ</p>

<h3>抽出方法は全部同じ</h3>

<hr />

<p>whereの条件指定の方法ですね。</p>

<p>以下の３つは、全て同じSQLを発行します</p>

<p>1.Hashで条件設定する方法(AR独自チックな感じで大体使う方法)</p>

<p><code>
Hoge.where(:title =&gt; "title", :id =&gt; 1)
</code></p>

<p>2.プレースホルダで地道にパラメータ設定する方法(どの言語でも通用する)</p>

<p><code>
Hoge.where("title = ? and id = ?", "title1", 1)
</code></p>

<p>3.シンボルで対応付けをわかりやすくする方法</p>

<p><code>
Hoge.where("title = :title and id = :id", {:title =&gt; "title", :id =&gt;1})
</code></p>

<h3>抽出結果がなかったらレコードの新規作成をする</h3>

<hr />

<p>これ、一発でできるメソッドあったんですね。<br/>
知らなかった。。。</p>

<p>どうやらfirst_or_createというメソッドを使えばよいみたい。<br/>
で、ブロックを取ることができるので、ブロック内で挿入する値を自由に設定できる</p>

<p>以下のような感じで書くとできる模様。</p>

<p>```
Hoge.where(:title => "title").first_or_create do |p|</p>

<pre><code>p.body = "hogehoge"
</code></pre>

<p>end
```</p>

<p>結局は裏で2回SQL発行してるだけなんですけどね。(selectとinsert)</p>

<p>と、まぁ色々とありますがこんなところで。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rubyでアクセス用のメソッドを定義する(アクセッサ)]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/07/25/ruby-accessor/"/>
    <updated>2013-07-25T20:56:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/07/25/ruby-accessor</id>
    <content type="html"><![CDATA[<p>なんてことはない、ただの整理です。</p>

<p>通常インスタンス変数を外部から参照する方法は、インスタンス変数を操作するgetter/setterメソッドを作ります。</p>

<p>Rubyでは、このアクセス用のメソッド(アクセッサ)を簡単に作る機能があります。</p>

<p>以下のようなModuleクラスにあるものを使います</p>

<ul>
<li>attr_reader : 参照(読み出し)できるようにする(getter)</li>
<li>attr_writer : 代入(書き込み)できるようにする(setter)</li>
<li>attr_accessor : 参照、代入の両方できるようにする(getter/setter)</li>
</ul>


<p>それぞれ、使い方は以下のような形になります。</p>

<p>```
class Accessor</p>

<pre><code>attr_reader :name,:hoge
attr_writer :fuga,:piyo
attr_accessor :access

def initialize
    @name = "kurobara"
    @hoge = "hogehoge"
    @fuga = "fugafuga"
    @piyo = "piypiyo"
    @access = "OK"
end

def print_fuga_piyo
    p '---------------------'
    puts "fuga = " + @fuga
    puts "piyo = " + @piyo
end
</code></pre>

<p>end</p>

<p>a = Accessor.new()
puts a.name
puts a.hoge<br/>
a.print_fuga_piyo
p "代入操作"
a.fuga = "fuga2fuga2"
a.piyo = "piyo2piyo2"
a.print_fuga_piyo
p '---------------------'
puts 'a.access = ' + a.access
p "代入操作"
a.access = "OKOK"
puts 'a.access = ' + a.access
```</p>

<p>こんな感じで使えちゃいます。。。<br/>
今更初心者みたいなことしてんなって突っ込まれそうだけど・・・<br/>
attr_accessorばっかり使うので、attr_reader,att_writerを忘れてましたｗ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyでSingletonパターンを実装する]]></title>
    <link href="http://moonstruckdrops.github.com/blog/2013/07/25/ruby-singleton/"/>
    <updated>2013-07-25T18:33:00+09:00</updated>
    <id>http://moonstruckdrops.github.com/blog/2013/07/25/ruby-singleton</id>
    <content type="html"><![CDATA[<p>このまえ、友人とデザインパターンの話をしてたような気がするので書いてみた。</p>

<p>SingletonはGOFのデザインパターンの一つです。<br/>
使い所は、システム内で絶対に一つにしておかないといけないもの仕組みのものに使います。<br/>
例えば、アプリの設定とか見た目(Look&amp;Feel)とかシステムの何かを管理するだとかに使ったりします。</p>

<p>Singletonは以下の条件を満たす必要があります。</p>

<ul>
<li>作成したクラスのインスタンスは一つだけであることが保証されている</li>
<li>コード上のどこからでも、生成した1つだけのインスタンスにアクセスできる</li>
</ul>


<p>Javaで上の条件を満たすものはこんな感じ</p>

<p>```
final class Singleton {</p>

<pre><code>private static Singleton instance;
private Singleton(){};

public static synchronized Singleton getInstance(){
    if(instance == null){
        instance = new Singleton();
    }
    return instance;
}
</code></pre>

<p>}
```</p>

<p>これと同じ実装をRubyでやるとこんな感じになります。</p>

<p>```
class Singleton
  @@singleton_obj = nil
  @@count = 0</p>

<p>  # 以下の行をコメントアウトすると
  # オブジェクトが再生成されるので
  # シングルトンにならない
  private_class_method:new</p>

<p>  def initialize</p>

<pre><code>@@count = 1
</code></pre>

<p>  end</p>

<p>  def self.get_instance</p>

<pre><code>if @@singleton_obj == nil
  @@singleton_obj = new
end
@@singleton_obj
</code></pre>

<p>  end</p>

<p>  def self.count_up</p>

<pre><code>@@count+=1
</code></pre>

<p>  end</p>

<p>  def self.print_count</p>

<pre><code>p @@count
</code></pre>

<p>  end</p>

<p>end</p>

<p>p '-----------------------'
p '初回インスタンス取得'
p Singleton.get_instance
Singleton.print_count
p '-----------------------'
p '２回目のインスタンス取得でオブジェクトに変更がない'
p Singleton.get_instance
Singleton.count_up
Singleton.print_count
p '-----------------------'
p 'newするとエラーが飛ぶ'
begin
  Singleton.new
rescue
  p 'newでエラーが飛んだ'
end
```</p>

<p>結構長いですねw</p>

<p>上記のコードの実行結果は、以下になります。<br/>
オブジェクトに変化が無いことがわかりますね。<br/>
つまり、オブジェクトが１つであることが、保証されています。</p>

<p>```
"-----------------------"
"初回インスタンス取得"</p>

<h1>&lt;Singleton:0x007f91519026f0></h1>

<p>1
"-----------------------"
"２回目のインスタンス取得でオブジェクトに変更がない"</p>

<h1>&lt;Singleton:0x007f91519026f0></h1>

<p>2
"-----------------------"
"newするとエラーが飛ぶ"
"newでエラーが飛んだ"
```</p>

<p>自力でSingletonを実装すると上記のようなコードなのですが、<br/>
実は、Rubyにはsingletonをやってくれる便利なモジュールがあります。<br/>
これを使うと、Mix-inしたクラスのインスタンスは常に同じものを返してくれます。</p>

<p>```
require 'singleton'</p>

<p>class MySingleton</p>

<p>  include Singleton</p>

<p>  @@count = 0</p>

<p>  def initialize</p>

<pre><code>@@count = 1
</code></pre>

<p>  end</p>

<p>  def self.count_up</p>

<pre><code>@@count+=1
</code></pre>

<p>  end</p>

<p>  def self.print_count</p>

<pre><code>p @@count
</code></pre>

<p>  end
end</p>

<p>p '-----------------------'
p '初回インスタンス取得'
p MySingleton.instance
MySingleton.print_count
p '-----------------------'
p '２回目のインスタンス取得でオブジェクトに変更がない'
p MySingleton.instance
MySingleton.count_up
MySingleton.print_count
p '-----------------------'
p 'newするとエラーが飛ぶ'
begin
  MySingleton.new
rescue
  p 'newでエラーが飛んだ'
end
```</p>

<p>実行結果は、こんな感じ</p>

<p>```
"-----------------------"
"初回インスタンス取得"</p>

<h1>&lt;MySingleton:0x007fd2fa8c9658></h1>

<p>1
"-----------------------"
"２回目のインスタンス取得でオブジェクトに変更がない"</p>

<h1>&lt;MySingleton:0x007fd2fa8c9658></h1>

<p>2
"-----------------------"
"newするとエラーが飛ぶ"
"newでエラーが飛んだ"
```</p>

<p>モジュールを使うと、スッキリとしたコードになりますね。<br/>
当たり前ですが、newしようとするとエラーになります。</p>
]]></content>
  </entry>
  
</feed>
